name: Publish Release from Tag

on:
  # Auto-publish when a version tag like v4.2.2 is pushed
  push:
    tags:
      - 'v*'
  # Also react on tag creation (first time a tag is created)
  # Note: 'create' does not support path filters; we guard in the job with an if-condition
  create:
  # Manual trigger still supported (tag input optional)
  workflow_dispatch:
    inputs:
      tag:
        description: Git tag to publish (e.g., v4.2.2). Leave empty to use the event tag.
        required: false
        default: ''
      prerelease:
        description: Mark as prerelease (leave empty to auto-detect based on tag name)
        required: false
        default: ''

permissions:
  contents: write

jobs:
  publish:
    runs-on: ubuntu-latest
    # Only run on:
    # - push to tags matching v*
    # - create events where a tag starting with 'v' was created
    # - manual dispatch
    if: |
      github.event_name == 'workflow_dispatch' ||
      startsWith(github.ref, 'refs/tags/v') ||
      (github.event_name == 'create' && github.event.ref_type == 'tag' && startsWith(github.event.ref, 'v'))
    concurrency:
      group: publish-${{ github.ref || github.event.ref || github.run_id }}
      cancel-in-progress: true
    env:
      # Prefer the provided input, otherwise use the ref name (works for push on tags)
      # Fallback to event.ref for 'create' and to ref_name for push-tags; inputs for manual dispatch
      TAG: ${{ github.event.inputs.tag || github.ref_name || github.event.ref }}
      PRERELEASE_INPUT: ${{ github.event.inputs.prerelease }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Debug tag/ref context
        run: |
          echo "event_name=$GITHUB_EVENT_NAME"
          echo "github.ref=${{ github.ref }}"
          echo "github.ref_name=${{ github.ref_name }}"
          echo "event.ref=${{ github.event.ref }}"
          echo "event.ref_type=${{ github.event.ref_type }}"
          echo "derived TAG=${{ env.TAG }}"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install deps
        timeout-minutes: 15
        run: npm ci --ignore-scripts --no-audit --no-fund --omit=optional

      - name: Install UI deps (for ui:type-check)
        timeout-minutes: 10
        shell: bash
        run: |
          if [ -f ui/package-lock.json ]; then
            echo "Using ui/package-lock.json with npm ci (no scripts, no audit, omit optional)"
            npm --prefix ui ci --ignore-scripts --no-audit --no-fund --omit=optional
          else
            echo "No ui/package-lock.json found; running npm install (no scripts, no audit)"
            npm --prefix ui install --ignore-scripts --no-audit --no-fund
          fi

      - name: Print npm debug logs if install failed
        if: failure()
        shell: bash
        run: |
          echo "Listing npm logs (if any):"
          find "$HOME/.npm/_logs" -type f -name "*.log" -maxdepth 1 -print || true
          echo "--- tail of latest npm log ---"
          latest=$(ls -1t "$HOME/.npm/_logs"/*.log 2>/dev/null | head -n 1 || true)
          if [ -n "$latest" ]; then tail -n 200 "$latest"; else echo "No npm logs found"; fi

      - name: Verify (type + lint)
        id: verify
        shell: bash
        run: |
          set -o pipefail
          npm run -s verify 2>&1 | tee verify.log

      - name: Print verify log tail (for debugging)
        if: always()
        shell: bash
        run: |
          echo "--- verify.log (tail) ---"
          tail -n 400 verify.log || true
          echo "--- end verify.log (tail) ---"

      - name: Upload verify logs (artifact)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: verify-logs-${{ env.TAG }}
          path: verify.log
          retention-days: 7

      # Optional: surface VS Code extension build status without blocking releases
      - name: Build VS Code extension (non-blocking)
        continue-on-error: true
        run: |
          echo "Building VS Code extension (non-blocking)..."
          npm --prefix coreagent/vscode-extension install
          npm --prefix coreagent/vscode-extension run -s compile
        shell: bash

      - name: Sync README version from package.json
        run: |
          npm run sync:readme || true

      - name: Commit README update if present
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          if [ -n "$(git status --porcelain)" ]; then
            git add README.md
            git commit -m "chore(release): sync README version to package.json"
            git push origin HEAD:main
          else
            echo "No README changes"
          fi

      - name: Create or Update Release
        id: create_release
        uses: actions/github-script@v7
        env:
          TAG: ${{ env.TAG }}
          PRERELEASE_INPUT: ${{ env.PRERELEASE_INPUT }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const tag = process.env.TAG;
            if (!tag || !/^v\d+\.\d+\.\d+/.test(tag)) {
              core.setFailed(`Invalid or missing tag: "${tag}". Provide an input tag or run on a tag push.`);
              return;
            }

            // Determine prerelease: explicit input takes precedence; otherwise infer from tag suffixes
            const prereleaseInput = (process.env.PRERELEASE_INPUT || '').toLowerCase();
            const inferredPrerelease = /-(alpha|beta|rc)\d*$/i.test(tag);
            const prerelease = prereleaseInput === 'true' ? true : prereleaseInput === 'false' ? false : inferredPrerelease;

            // Prefer release notes file; fallback to extracting section from CHANGELOG.md; else simple body
            const notesPath = path.join(process.cwd(), 'RELEASE_NOTES', `${tag}.md`);
            let body = `Release ${tag}`;
            if (fs.existsSync(notesPath)) {
              body = fs.readFileSync(notesPath, 'utf8');
            } else {
              const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');
              if (fs.existsSync(changelogPath)) {
                const text = fs.readFileSync(changelogPath, 'utf8');
                const section = (function extractFromChangelog(markdown, tag) {
                  const lines = markdown.split(/\r?\n/);
                  const startPatterns = [
                    new RegExp(`^##\\s+${tag}\\b`),
                    new RegExp(`^##\\s+\\(${tag}\\)`),
                    new RegExp(`^##\\s+v?${tag.replace(/^v/, '')}\\b`),
                  ];
                  let start = -1;
                  for (let i = 0; i < lines.length; i++) {
                    if (startPatterns.some((r) => r.test(lines[i]))) { start = i; break; }
                  }
                  if (start === -1) return '';
                  let end = lines.length;
                  for (let i = start + 1; i < lines.length; i++) {
                    if (/^##\s+/.test(lines[i])) { end = i; break; }
                  }
                  return lines.slice(start, end).join('\n');
                })(text, tag);
                if (section && section.trim()) {
                  body = section;
                }
              }
            }

            async function createOrUpdateRelease() {
              try {
                // Try to get an existing release by tag
                let release;
                try {
                  const { data } = await github.rest.repos.getReleaseByTag({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag,
                  });
                  release = data;
                } catch (e) {
                  if (e.status !== 404) throw e;
                }

                // GitHub API expects make_latest as a string: 'true' | 'false' | 'legacy'
                const make_latest = prerelease ? 'false' : 'true';

                if (release) {
                  // Update existing release
                  const { data } = await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: release.id,
                    tag_name: tag,
                    name: tag,
                    body,
                    prerelease,
                    make_latest,
                  });
                  core.notice(`Release updated: ${data.html_url}`);
                  console.log(data.html_url);
                  return;
                }

                // Create release if not exists
                const { data } = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: tag,
                  name: tag,
                  body,
                  prerelease,
                  make_latest,
                });
                core.notice(`Release created: ${data.html_url}`);
                console.log(data.html_url);
              } catch (err) {
                core.setFailed(err.message);
              }
            }

            await createOrUpdateRelease();
