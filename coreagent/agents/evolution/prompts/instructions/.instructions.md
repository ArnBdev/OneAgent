# OneAgent Professional Development Instructions for GitHub Copilot

## ðŸ§  MEMORY-FIRST DEVELOPMENT WORKFLOW (REALISTIC IMPLEMENTATION)

### **MEMORY SYSTEM INTEGRATION - BASED ON ACTUAL CAPABILITIES**

**BEFORE EVERY development session (MANDATORY):**
1. **`oneagent_memory_context`** - Search for relevant patterns, solutions, and context using natural language queries
2. **`oneagent_system_health`** - Verify memory system health and connectivity  
3. **Broad Pattern Search**: Use general queries to discover existing knowledge
4. **Context Discovery**: Search for project-specific and technical knowledge

**DURING EVERY development task (CONTINUOUS):**
5. **Targeted Memory Queries**: Use specific technical terms and problem descriptions
6. **Solution Discovery**: Search for similar implementations and approaches
7. **Decision Context**: Look for relevant architectural and design information
8. **Learning Integration**: Build on existing stored knowledge

**AFTER EVERY development task (STORE LEARNINGS):**
9. **`oneagent_memory_create`** - Store successful patterns, solutions, and insights
10. **Knowledge Capture**: Document what worked and why
11. **Pattern Storage**: Save reusable code patterns and approaches
12. **Quality Documentation**: Record quality improvements and lessons learned

### **MEMORY-DRIVEN DEVELOPMENT APPROACH (PRACTICAL)**

**Essential Memory Practices:**
- **Before implementing**: Search memory for similar solutions and approaches
- **During development**: Query memory for relevant patterns and best practices  
- **After completion**: Store successful solutions and learned patterns
- **For debugging**: Search for similar issues and resolution approaches
- **For decisions**: Look for previous architectural choices and outcomes

**Effective Memory Queries:**
- Use **natural language descriptions** of problems and solutions
- Include **technical terms** and **technology stack** keywords
- Search for **problem types** rather than exact implementations
- Query for **architectural patterns** and **design decisions**
- Look for **quality examples** and **best practices**

**Memory Storage Strategy:**
- Store **complete solutions** with context and reasoning
- Document **architectural decisions** with alternatives considered
- Save **debugging insights** with problem descriptions
- Record **quality patterns** with success metrics
- Capture **lessons learned** with applicable contexts

### **REALISTIC MEMORY SEARCH PATTERNS**

**Effective Search Examples:**
```typescript
// Search for implementation patterns
await oneagent_memory_context({
  query: "authentication middleware express typescript",
  context: "Looking for auth implementation patterns for Express API"
});

// Search for architectural decisions
await oneagent_memory_context({
  query: "database connection pooling node.js performance",
  context: "Need guidance on database connection management"
});

// Search for debugging solutions
await oneagent_memory_context({
  query: "typescript type error resolution",
  context: "Troubleshooting type definition issues"
});

// Search for quality patterns
await oneagent_memory_context({
  query: "error handling best practices javascript",
  context: "Implementing robust error handling"
});
```

**Memory-First Development Process:**
1. **Research Phase**: Query memory for existing solutions and patterns
2. **Implementation Phase**: Apply found patterns with adaptations
3. **Testing Phase**: Use memory for testing strategies and patterns
4. **Documentation Phase**: Store successful implementations
5. **Review Phase**: Compare results with stored quality standards

### **ENHANCED MEMORY WORKFLOW INTEGRATION**

### âœ… 1. Implementation Summary (Memory-Enhanced)
- **Memory Queries Performed**: List searches conducted and their effectiveness
- **Patterns Applied**: Document which stored patterns were used
- **Adaptations Made**: Describe how patterns were modified for current context
- **Success Metrics**: Measure effectiveness of memory-guided development

### ðŸ§  2. Memory Learning & Storage (PRACTICAL)
- **`oneagent_memory_create`**: Store new solutions including:
  - Complete implementation context and problem description
  - Technology stack and specific requirements
  - Code examples with explanations
  - Success metrics and quality assessments
  - Lessons learned and improvement opportunities

### ðŸ§¾ 3. Documentation Update (Memory-Integrated)
- **Pattern Documentation**: Link implementations to stored memory patterns
- **Decision Recording**: Document how memory influenced architectural choices
- **Knowledge Building**: Show progression from stored patterns to new solutions

### ðŸ“Œ 4. Suggest Next Step (Memory-Informed)
- **`oneagent_memory_context`**: Search for logical next steps based on current progress
- **Pattern Continuation**: Use stored patterns to predict development needs
- **Quality Guidance**: Apply memory-stored quality standards to next steps

## System Overview
You are working with OneAgent, a Professional AI Development Platform featuring Constitutional AI, BMAD Framework analysis, and quality-first development principles. The system provides advanced tools for enhanced code quality, systematic analysis, and professional standards.

## Available OneAgent Tools (MCP Integration) - VERIFIED

### Constitutional AI Tools
- `oneagent_constitutional_validate`: Validate responses against 4 core principles (Accuracy, Transparency, Helpfulness, Safety)
- `oneagent_quality_score`: Generate quality scoring with professional grading (A-D scale)
- `oneagent_bmad_analyze`: Systematic task analysis using 9-point BMAD framework

### Enhanced Development Tools
- `oneagent_memory_context`: Retrieve relevant context using natural language queries
- `oneagent_memory_create`: Create new memory entries with content and metadata
- `oneagent_enhanced_search`: Web search with quality filtering and professional scoring
- `oneagent_ai_assistant`: AI assistance with Constitutional AI validation
- `oneagent_semantic_analysis`: Advanced semantic analysis with embeddings
- `oneagent_system_health`: Comprehensive system health and performance metrics
- `oneagent_web_fetch`: Web content fetching with HTML parsing

## Development Standards

### Code Quality Requirements
1. **Professional Standards**: All code must meet enterprise-grade quality levels
2. **Constitutional Compliance**: Apply Constitutional AI validation for critical decisions
3. **Quality Scoring**: Target minimum 80% quality score (Grade A) for production code
4. **BMAD Analysis**: Use systematic analysis for complex architectural decisions
5. **Memory-First Development**: Always search memory before implementing new solutions

### Architectural Principles
1. **Modular Design**: Component-based architecture with clear separation of concerns
2. **Type Safety**: Full TypeScript implementation with strict typing
3. **Error Handling**: Comprehensive error handling with graceful fallbacks
4. **Performance**: Optimize for scalability and maintainability
5. **Documentation**: Self-documenting code with clear reasoning
6. **Memory Integration**: Store and retrieve patterns for continuous improvement

### Best Practices
1. **Memory Context**: Leverage persistent memory for project continuity
2. **Quality Validation**: Apply Constitutional AI validation for user-facing features
3. **Systematic Analysis**: Use BMAD framework for complex problem-solving
4. **Enhanced Search**: Utilize quality-filtered search for research and documentation
5. **Pattern Storage**: Store successful solutions for future reference

## Workflow Guidelines

### For New Features (Memory-Enhanced)
1. **`oneagent_memory_context`**: Search for existing patterns and solutions
2. Analyze requirements using `oneagent_bmad_analyze`
3. Search for best practices using `oneagent_enhanced_search`
4. Implement with Constitutional AI principles
5. Validate quality using `oneagent_quality_score`
6. **`oneagent_memory_create`**: Store successful patterns for future use

### For Code Review (Memory-Integrated)
1. **`oneagent_memory_context`**: Check for relevant quality patterns and standards
2. Apply `oneagent_constitutional_validate` to critical logic
3. Ensure quality score meets minimum threshold (80%)
4. Check system health impact using `oneagent_system_health`
5. Document decisions and reasoning clearly
6. **`oneagent_memory_create`**: Store quality insights and improvements

### For Problem Solving (Memory-First)
1. **`oneagent_memory_context`**: Search for similar problems and solutions
2. Use BMAD framework for systematic analysis
3. Apply Constitutional AI for solution validation
4. Leverage semantic analysis for complex relationships
5. Maintain quality standards throughout process
6. **`oneagent_memory_create`**: Store solution patterns for future reference

## Quality Standards

### Minimum Requirements
- Quality Score: 80% (Grade A)
- Constitutional Compliance: 100%
- Type Safety: Strict TypeScript
- Error Handling: Comprehensive coverage
- Documentation: Clear and complete
- Memory Integration: Patterns stored and retrievable

### Professional Enhancement
- Apply Constitutional AI for user-facing content
- Use BMAD analysis for architectural decisions
- Leverage memory context for project continuity
- Implement quality scoring for continuous improvement
- Build comprehensive knowledge base in memory

## Integration Notes

### OneAgent MCP Server
- Port: 8083 (Professional), 8080 (Legacy)
- Protocol: HTTP MCP with JSON-RPC 2.0
- Version: 4.0.0 Professional Grade
- Status: GitHub Copilot Agent Mode Ready
- Memory System: Natural language query-based with persistent storage

### Constitutional AI Principles
1. **Accuracy**: Prefer "I don't know" to speculation
2. **Transparency**: Explain reasoning and acknowledge limitations  
3. **Helpfulness**: Provide actionable, relevant guidance
4. **Safety**: Avoid harmful or misleading recommendations

### BMAD Framework (9-Point Analysis)
1. Belief Assessment
2. Motivation Mapping
3. Authority Identification
4. Dependency Mapping
5. Constraint Analysis
6. Risk Assessment
7. Success Metrics
8. Timeline Considerations
9. Resource Requirements

## Tool Usage Examples

```typescript
// Memory-first development approach
const existingPatterns = await oneagent_memory_context({
  query: "authentication middleware typescript express",
  context: "Looking for existing auth patterns before implementing new solution"
});

// Constitutional validation for critical logic
const validation = await oneagent_constitutional_validate({
  response: codeImplementation,
  userMessage: requirement,
  context: projectContext
});

// Quality scoring for code review
const quality = await oneagent_quality_score({
  content: sourceCode,
  criteria: ['accuracy', 'maintainability', 'performance']
});

// Store successful patterns
await oneagent_memory_create({
  content: `Authentication Middleware Pattern

## Problem
Need secure authentication middleware for Express.js API with TypeScript

## Solution
${successfulImplementation}

## Context
- Technology: Express.js, TypeScript, JWT
- Quality Score: ${qualityScore}
- Use Cases: API authentication, token validation
- Lessons Learned: ${lessonsLearned}`,
  
  metadata: {
    type: "implementation_pattern",
    technology: "express-typescript",
    category: "authentication",
    quality_score: qualityResult.score
  }
});
```

Remember: OneAgent emphasizes memory-first, quality-driven development with systematic analysis and Constitutional AI validation. Always search memory first, implement with quality standards, and store learnings for future use.