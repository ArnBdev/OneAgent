/**
 * generate-mission-control-types.ts
 *
 * Canonical JSON Schema → TypeScript type generation for Mission Control
 * Inbound / Outbound message envelopes. Ensures runtime schema and compile-time
 * types never drift. This avoids manual maintenance of discriminated unions
 * like MissionUpdatePayload which already diverged from schema (missing new statuses).
 *
 * Lightweight zero-dependency implementation (no external codegen library) to
 * stay within existing toolchain. If future schemas become more complex,
 * consider integrating a vetted library (e.g. json-schema-to-typescript) via
 * explicit dependency review.
 */
import fs from 'fs';
import path from 'path';

interface JsonSchema {
  oneOf?: JsonSchema[];
  type?: string | string[];
  const?: unknown;
  enum?: unknown[];
  properties?: Record<string, JsonSchema>;
  required?: string[];
  additionalProperties?: boolean | JsonSchema;
  $ref?: string;
}

const ROOT = process.cwd();
const SCHEMA_DIR = path.join(ROOT, 'coreagent', 'server', 'mission-control', 'schemas');
const OUT_FILE = path.join(
  ROOT,
  'coreagent',
  'server',
  'mission-control',
  'generated',
  'mission-control-message-types.ts',
);

function loadSchema(file: string): JsonSchema {
  const raw = fs.readFileSync(file, 'utf8');
  // Strip potential UTF-8 BOM and any zero-width chars sometimes introduced by editors
  const cleaned = raw.replace(/^\uFEFF/, '');
  return JSON.parse(cleaned) as JsonSchema;
}

function schemaToTsType(name: string, schema: JsonSchema): string {
  // We specifically expect top-level oneOf with object variants.
  if (schema.oneOf) {
    return schema.oneOf.map((s, idx) => variantToInterface(`${name}${idx + 1}`, s)).join(' | ');
  }
  return 'unknown';
}

function variantToInterface(name: string, schema: JsonSchema): string {
  if (schema.type !== 'object') return 'never';
  const required = new Set(schema.required || []);
  const props: string[] = [];
  for (const [key, prop] of Object.entries(schema.properties || {})) {
    const opt = required.has(key) ? '' : '?';
    props.push(`${JSON.stringify(key)}${opt}: ${propToTs(prop)};`);
  }
  const allowExtra = schema.additionalProperties === undefined || schema.additionalProperties;
  if (allowExtra) {
    props.push(`[k: string]: unknown;`);
  }
  return `{ ${props.join(' ')} }`;
}

function propToTs(prop: JsonSchema): string {
  if (prop.const !== undefined) {
    return JSON.stringify(prop.const);
  }
  if (prop.enum) {
    return prop.enum.map((v) => JSON.stringify(v)).join(' | ');
  }
  if (prop.type) {
    if (Array.isArray(prop.type)) {
      return prop.type.map(mapPrimitive).join(' | ');
    }
    if (prop.type === 'object') return '{ [k: string]: unknown }';
    if (prop.type === 'array') {
      // Narrow simple homogeneous arrays of primitive types when possible
      const itemsSchema = (prop as unknown as { items?: JsonSchema }).items;
      if (itemsSchema && itemsSchema.type && typeof itemsSchema.type === 'string') {
        const mapped = mapPrimitive(itemsSchema.type);
        return `${mapped}[]`;
      }
      return 'unknown[]';
    }
    return mapPrimitive(prop.type);
  }
  return 'unknown';
}

function mapPrimitive(t: string): string {
  switch (t) {
    case 'string':
    case 'number':
    case 'boolean':
      return t;
    case 'null':
      return 'null';
    default:
      return 'unknown';
  }
}

function ensureDirFor(file: string): void {
  const dir = path.dirname(file);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function main(): void {
  const inboundSchema = loadSchema(path.join(SCHEMA_DIR, 'mission-control-messages.schema.json'));
  const outboundSchema = loadSchema(
    path.join(SCHEMA_DIR, 'mission-control-outbound-messages.schema.json'),
  );

  const inboundType = schemaToTsType('Inbound', inboundSchema);
  const outboundType = schemaToTsType('Outbound', outboundSchema);

  const banner = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-mission-control-types.ts
// Source of truth: JSON Schemas in mission-control/schemas
// Generation Time: ${new Date().toISOString()}
`;

  const content = `${banner}
export type InboundMissionControlMessage = ${inboundType};
export type OutboundMissionControlMessage = ${outboundType};

// Narrow helper discriminators (runtime type guards)
export function isMissionUpdate(msg: OutboundMissionControlMessage & { type?: unknown }): msg is Extract<OutboundMissionControlMessage, { type: 'mission_update' }> { return (msg as any).type === 'mission_update'; }
export function isMissionAck(msg: OutboundMissionControlMessage & { type?: unknown }): msg is Extract<OutboundMissionControlMessage, { type: 'mission_ack' }> { return (msg as any).type === 'mission_ack'; }
`;

  ensureDirFor(OUT_FILE);
  let prev = '';
  if (fs.existsSync(OUT_FILE)) prev = fs.readFileSync(OUT_FILE, 'utf8');
  if (prev !== content) {
    fs.writeFileSync(OUT_FILE, content, 'utf8');
    console.log(`Wrote generated types → ${path.relative(process.cwd(), OUT_FILE)}`);
  } else {
    console.log('No changes to generated mission control types.');
  }
}

main();
