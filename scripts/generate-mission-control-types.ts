/**
 * generate-mission-control-types.ts
 *
 * Canonical JSON Schema → TypeScript type generation for Mission Control
 * Inbound / Outbound message envelopes. Ensures runtime schema and compile-time
 * types never drift. This avoids manual maintenance of discriminated unions
 * like MissionUpdatePayload which already diverged from schema (missing new statuses).
 *
 * Lightweight zero-dependency implementation (no external codegen library) to
 * stay within existing toolchain. If future schemas become more complex,
 * consider integrating a vetted library (e.g. json-schema-to-typescript) via
 * explicit dependency review.
 */
import fs from 'fs';
import path from 'path';

interface JsonSchema {
  oneOf?: JsonSchema[];
  type?: string | string[];
  const?: unknown;
  enum?: unknown[];
  properties?: Record<string, JsonSchema>;
  required?: string[];
  additionalProperties?: boolean | JsonSchema;
  $ref?: string;
}

const ROOT = process.cwd();
const SCHEMA_DIR = path.join(ROOT, 'coreagent', 'server', 'mission-control', 'schemas');
const OUT_FILE = path.join(
  ROOT,
  'coreagent',
  'server',
  'mission-control',
  'generated',
  'mission-control-message-types.ts',
);

function loadSchema(file: string): JsonSchema {
  const raw = fs.readFileSync(file, 'utf8');
  // Strip potential UTF-8 BOM and any zero-width chars sometimes introduced by editors
  const cleaned = raw.replace(/^\uFEFF/, '');
  return JSON.parse(cleaned) as JsonSchema;
}

function schemaToVariantInterfaces(
  prefix: string,
  schema: JsonSchema,
): { names: string[]; code: string } {
  if (!schema.oneOf) return { names: [], code: '' };
  const names: string[] = [];
  const blocks: string[] = [];
  for (const variant of schema.oneOf) {
    if (variant.type !== 'object') continue;
    // Determine discriminant name by const type property if present
    const typeProp = Object.entries(variant.properties || {}).find(([, v]) => v.const);
    const disc = typeof typeProp?.[1].const === 'string' ? String(typeProp[1].const) : 'variant';
    const ifaceName = `${prefix}_${disc.replace(/[^a-zA-Z0-9]/g, '_')}`;
    names.push(ifaceName);
    const required = new Set(variant.required || []);
    const props: string[] = [];
    for (const [key, prop] of Object.entries(variant.properties || {})) {
      const opt = required.has(key) ? '' : '?';
      props.push(`${JSON.stringify(key)}${opt}: ${propToTs(prop)};`);
    }
    const allowExtra = variant.additionalProperties === undefined || variant.additionalProperties;
    if (allowExtra) props.push(`[k: string]: unknown;`);
    blocks.push(
      `/** Auto-generated interface for '${disc}' variant */\nexport interface ${ifaceName} { ${props.join(' ')} }`,
    );
  }
  return { names, code: blocks.join('\n\n') };
}

function propToTs(prop: JsonSchema): string {
  if (prop.const !== undefined) {
    return JSON.stringify(prop.const);
  }
  if (prop.enum) {
    return prop.enum.map((v) => JSON.stringify(v)).join(' | ');
  }
  if (prop.type) {
    if (Array.isArray(prop.type)) {
      return prop.type.map(mapPrimitive).join(' | ');
    }
    if (prop.type === 'object') return '{ [k: string]: unknown }';
    if (prop.type === 'array') {
      // Narrow simple homogeneous arrays of primitive types when possible
      const itemsSchema = (prop as unknown as { items?: JsonSchema }).items;
      if (itemsSchema && itemsSchema.type && typeof itemsSchema.type === 'string') {
        const mapped = mapPrimitive(itemsSchema.type);
        return `${mapped}[]`;
      }
      return 'unknown[]';
    }
    return mapPrimitive(prop.type);
  }
  return 'unknown';
}

function mapPrimitive(t: string): string {
  switch (t) {
    case 'string':
    case 'number':
    case 'boolean':
      return t;
    case 'null':
      return 'null';
    default:
      return 'unknown';
  }
}

function ensureDirFor(file: string): void {
  const dir = path.dirname(file);
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function main(): void {
  const inboundSchema = loadSchema(path.join(SCHEMA_DIR, 'mission-control-messages.schema.json'));
  const outboundSchema = loadSchema(
    path.join(SCHEMA_DIR, 'mission-control-outbound-messages.schema.json'),
  );

  const inboundVariants = schemaToVariantInterfaces('Inbound', inboundSchema);
  const outboundVariants = schemaToVariantInterfaces('Outbound', outboundSchema);
  const inboundType = inboundVariants.names.join(' | ') || 'unknown';
  const outboundType = outboundVariants.names.join(' | ') || 'unknown';

  const banner = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-mission-control-types.ts
// Source of truth: JSON Schemas in mission-control/schemas
// Generation Time: ${new Date().toISOString()}
`;

  const content = `${banner}
// Inbound variant interfaces
${inboundVariants.code}

// Outbound variant interfaces
${outboundVariants.code}

export type InboundMissionControlMessage = ${inboundType};
export type OutboundMissionControlMessage = ${outboundType};

// Narrow helper discriminators (runtime type guards)
export function isMissionUpdate(msg: OutboundMissionControlMessage & { type?: unknown }): msg is Extract<OutboundMissionControlMessage, { type: 'mission_update' }> { return (msg as { type?: unknown }).type === 'mission_update'; }
export function isMissionAck(msg: OutboundMissionControlMessage & { type?: unknown }): msg is Extract<OutboundMissionControlMessage, { type: 'mission_ack' }> { return (msg as { type?: unknown }).type === 'mission_ack'; }
`;

  ensureDirFor(OUT_FILE);
  let prev = '';
  if (fs.existsSync(OUT_FILE)) prev = fs.readFileSync(OUT_FILE, 'utf8');
  if (prev !== content) {
    fs.writeFileSync(OUT_FILE, content, 'utf8');
    console.log(`Wrote generated types → ${path.relative(process.cwd(), OUT_FILE)}`);
  } else {
    console.log('No changes to generated mission control types.');
  }
}

main();
