import { oneAgentConfig } from '../config/index';

/**
 * OneAgent Unified Memory System - Core Interface
 * 
 * This interface defines the foundation for all agent memory operations.
 * All agents (DevAgent, Context7, etc.) use this single interface for:
 * - Storing conversations, learnings, and patterns
 * - Cross-agent semantic search and retrieval
 * - Organic growth and learning transfer
 * 
 * Uses centralized configuration from ../config/index.ts
 * 
 * @version 1.0.0
 * @created June 13, 2025
 * @updated December 16, 2024 - Added centralized configuration
 */

// =====================================
// Core Memory Types
// =====================================

export interface ConversationMemory {
  id: string;
  agentId: string;
  userId: string;
  timestamp: Date;
  content: string;
  context: AgentContext;
  outcome: ConversationOutcome;
  embeddings?: number[]; // Generated by server
  metadata?: Record<string, any>;
}

export interface LearningMemory {
  id: string;
  agentId: string;
  learningType: LearningType;
  content: string;
  confidence: number; // 0-1 confidence score
  applicationCount: number;
  lastApplied: Date;
  sourceConversations: string[];
  embeddings?: number[];
  metadata?: Record<string, any>;
}

export interface PatternMemory {
  id: string;
  agentId: string;
  patternType: PatternType;
  description: string;
  frequency: number;
  strength: number; // 0-1 strength score
  conditions: PatternCondition[];
  outcomes: PatternOutcome[];
  embeddings?: number[];
  metadata?: Record<string, any>;
}

// =====================================
// Supporting Types
// =====================================

export interface AgentContext {
  actionType?: string;
  codeContext?: string;
  userPreferences?: Record<string, any>;
  sessionId?: string;
  environment?: string;
  [key: string]: any;
}

export interface ConversationOutcome {
  success: boolean;
  satisfaction?: 'high' | 'medium' | 'low' | 'pending';
  errorType?: string;
  learningsExtracted?: number;
  qualityScore?: number;
  [key: string]: any;
}

export type LearningType = 
  | 'pattern' 
  | 'solution' 
  | 'preference' 
  | 'error' 
  | 'optimization'
  | 'cross_agent_transfer'
  | 'documentation_context'
  | 'code_analysis'
  | 'user_behavior';

export type PatternType = 
  | 'behavioral' 
  | 'functional' 
  | 'error' 
  | 'success' 
  | 'user_preference'
  | 'code_pattern'
  | 'documentation_pattern'
  | 'interaction_pattern';

export interface PatternCondition {
  type: string;
  value: any;
  operator?: 'equals' | 'contains' | 'greater_than' | 'less_than' | 'regex';
}

export interface PatternOutcome {
  type: string;
  confidence: number;
  impact?: string;
  measuredEffect?: number;
}

// =====================================
// Search and Retrieval Types
// =====================================

export interface MemorySearchQuery {
  query: string;
  agentIds?: string[];
  memoryTypes?: ('conversation' | 'learning' | 'pattern')[];
  dateRange?: {
    start: Date;
    end: Date;
  };
  confidenceThreshold?: number;
  maxResults?: number;
  semanticSearch?: boolean;
}

export interface MemoryResult {
  id: string;
  type: 'conversation' | 'learning' | 'pattern';
  content: string;
  agentId: string;
  relevanceScore: number;
  timestamp: Date;
  metadata: Record<string, any>;
  summary?: string;
}

// =====================================
// Organic Growth Types
// =====================================

export interface EmergingPattern {
  id: string;
  description: string;
  agentIds: string[];
  confidence: number;
  frequency: number;
  potentialApplications: string[];
  emergenceDate: Date;
  strength: number;
}

export interface CrossAgentLearning {
  id: string;
  sourceAgent: string;
  targetAgent: string;
  learningType: LearningType;
  content: string;
  confidence: number;
  expectedImpact: string;
  transferDate?: Date;
  applicationResult?: {
    success: boolean;
    actualImpact: string;
    qualityChange: number;
  };
}

// =====================================
// Main Unified Memory Interface
// =====================================

export interface UnifiedMemoryInterface {
  // =====================================
  // Core Storage Operations
  // =====================================
  
  /**
   * Store a conversation for any agent
   * All agent interactions should be stored here
   */
  storeConversation(conversation: ConversationMemory): Promise<string>;
  
  /**
   * Store a learning extracted from agent interactions
   * Used for pattern recognition and future application
   */
  storeLearning(learning: LearningMemory): Promise<string>;
  
  /**
   * Store a behavioral or functional pattern
   * Used for cross-agent learning and optimization
   */
  storePattern(pattern: PatternMemory): Promise<string>;

  // =====================================
  // Search and Retrieval Operations
  // =====================================
  
  /**
   * Semantic search across all memory types
   * Supports cross-agent search and filtering
   */
  searchMemories(query: MemorySearchQuery): Promise<MemoryResult[]>;
  
  /**
   * Find learnings related to a specific memory
   * Used for contextual enhancement
   */
  findRelatedLearnings(memoryId: string, agentId?: string): Promise<LearningMemory[]>;
  
  /**
   * Get all patterns for a specific agent
   * Used for agent-specific optimization
   */
  getAgentPatterns(agentId: string, patternType?: PatternType): Promise<PatternMemory[]>;
  
  /**
   * Get conversation history for context
   * Used for maintaining conversation continuity
   */
  getConversationHistory(userId: string, agentId?: string, limit?: number): Promise<ConversationMemory[]>;

  // =====================================
  // Organic Growth Operations
  // =====================================
  
  /**
   * Identify emerging patterns across agents
   * Core of the organic growth engine
   */
  identifyEmergingPatterns(): Promise<EmergingPattern[]>;
  
  /**
   * Suggest cross-agent learning opportunities
   * Enables agents to learn from each other
   */
  suggestCrossAgentLearnings(): Promise<CrossAgentLearning[]>;
  
  /**
   * Apply a cross-agent learning transfer
   * Safely transfer knowledge between agents
   */
  applyCrossAgentLearning(learning: CrossAgentLearning): Promise<boolean>;

  // =====================================
  // Analytics and Insights
  // =====================================
  
  /**
   * Get memory system analytics
   * Used for monitoring and optimization
   */
  getSystemAnalytics(agentId?: string): Promise<MemoryAnalytics>;
  
  /**
   * Get quality metrics for stored memories
   * Used for quality monitoring and improvement
   */
  getQualityMetrics(timeRange?: { start: Date; end: Date }): Promise<QualityMetrics>;
}

// =====================================
// Analytics Types
// =====================================

export interface MemoryAnalytics {
  totalConversations: number;
  totalLearnings: number;
  totalPatterns: number;
  agentActivity: Record<string, {
    conversations: number;
    learnings: number;
    patterns: number;
    lastActivity: Date;
  }>;
  emergingPatterns: number;
  crossAgentTransfers: number;
  qualityTrends: {
    averageQuality: number;
    improvementRate: number;
    trending: 'up' | 'down' | 'stable';
  };
}

export interface QualityMetrics {
  averageQualityScore: number;
  qualityDistribution: Record<string, number>;
  agentQualityScores: Record<string, number>;
  qualityTrends: Array<{
    date: Date;
    score: number;
    agentId?: string;
  }>;
  improvementAreas: string[];
  constitutionalCompliance: number;
}

// =====================================
// Error Types
// =====================================

export class MemoryError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: any
  ) {
    super(message);
    this.name = 'MemoryError';
  }
}

export class ValidationError extends MemoryError {
  constructor(message: string, details?: any) {
    super(message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

export class StorageError extends MemoryError {
  constructor(message: string, details?: any) {
    super(message, 'STORAGE_ERROR', details);
    this.name = 'StorageError';
  }
}

export class SearchError extends MemoryError {
  constructor(message: string, details?: any) {
    super(message, 'SEARCH_ERROR', details);
    this.name = 'SearchError';
  }
}

// =====================================
// Configuration Types
// =====================================

export interface MemoryConfig {
  serverUrl: string;
  maxRetries: number;
  retryDelay: number;
  timeout: number;
  enableEmbeddings: boolean;
  embeddingModel: string;
  qualityThreshold: number;
  constitutionalValidation: boolean;
}

export const DEFAULT_MEMORY_CONFIG: MemoryConfig = {
  serverUrl: oneAgentConfig.memoryUrl,
  maxRetries: 3,
  retryDelay: 1000,
  timeout: 30000,
  enableEmbeddings: true,
  embeddingModel: 'gemini',
  qualityThreshold: 0.85,
  constitutionalValidation: true
};

// =====================================
// Utility Functions
// =====================================

/**
 * Generate a unique ID for memory entries
 */
export function generateMemoryId(): string {
  return `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Validate a conversation memory object
 */
export function validateConversationMemory(conversation: ConversationMemory): void {
  if (!conversation.id) throw new ValidationError('Conversation ID is required');
  if (!conversation.agentId) throw new ValidationError('Agent ID is required');
  if (!conversation.userId) throw new ValidationError('User ID is required');
  if (!conversation.content) throw new ValidationError('Content is required');
  if (!conversation.timestamp) throw new ValidationError('Timestamp is required');
}

/**
 * Validate a learning memory object
 */
export function validateLearningMemory(learning: LearningMemory): void {
  if (!learning.id) throw new ValidationError('Learning ID is required');
  if (!learning.agentId) throw new ValidationError('Agent ID is required');
  if (!learning.content) throw new ValidationError('Learning content is required');
  if (learning.confidence < 0 || learning.confidence > 1) {
    throw new ValidationError('Confidence must be between 0 and 1');
  }
}

/**
 * Validate a pattern memory object
 */
export function validatePatternMemory(pattern: PatternMemory): void {
  if (!pattern.id) throw new ValidationError('Pattern ID is required');
  if (!pattern.agentId) throw new ValidationError('Agent ID is required');
  if (!pattern.description) throw new ValidationError('Pattern description is required');
  if (pattern.strength < 0 || pattern.strength > 1) {
    throw new ValidationError('Strength must be between 0 and 1');
  }
}
