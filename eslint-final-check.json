[{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\CodeAnalysisTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\ConversationRetrievalTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\ConversationSearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\EnhancedSearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemoryAddTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemoryDeleteTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemoryEditTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemorySearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\SmartGeminiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\SystemHealthTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\ToolRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedContext7QueryTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedContext7StoreTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedMCPTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedWebFetchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedWebSearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\braveSearchClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\geminiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\geminiEmbeddings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\webFetch.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":370,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":370,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// filepath: coreagent/tools/webFetch.ts\r\n// Web content fetching and extraction tool\r\n\r\nimport axios, { AxiosInstance, AxiosResponse } from 'axios';\r\nimport { JSDOM } from 'jsdom';\r\nimport { \r\n  WebFetchOptions, \r\n  WebFetchResponse, \r\n  WebFetchContent, \r\n  WebFetchMetadata,\r\n  WebFetchConfig,\r\n  WebFetchError\r\n} from '../types/webFetch';\r\n\r\nexport class WebFetchTool {\r\n  private client: AxiosInstance;\r\n  private config: WebFetchConfig;\r\n  private mockMode: boolean = false;\r\n  private lastRequestTime: number = 0;\r\n  private requestCount: number = 0;\r\n\r\n  constructor(config?: Partial<WebFetchConfig>) {\r\n    this.config = {\r\n      defaultTimeout: 10000,\r\n      defaultUserAgent: 'OneAgent-WebFetchTool/1.0 (https://github.com/oneagent)',\r\n      maxRetries: 3,\r\n      retryDelay: 1000,\r\n      maxContentSize: 10 * 1024 * 1024, // 10MB\r\n      allowedContentTypes: [\r\n        'text/html',\r\n        'text/plain',\r\n        'text/xml',\r\n        'application/xml',\r\n        'application/json',\r\n        'text/markdown',\r\n        'text/css',\r\n        'application/javascript',\r\n        'text/javascript'\r\n      ],\r\n      rateLimit: {\r\n        requestsPerSecond: 2,\r\n        requestsPerMinute: 60\r\n      },\r\n      ...config\r\n    };    // Enable mock mode in test environment or when specified\r\n    this.mockMode = process.env.NODE_ENV === 'test' || (config?.defaultUserAgent?.includes('mock') ?? false);\r\n\r\n    if (!this.mockMode) {\r\n      this.client = axios.create({\r\n        timeout: this.config.defaultTimeout,\r\n        maxRedirects: 5,\r\n        validateStatus: (status) => status < 500, // Don't throw on client errors (4xx)\r\n        headers: {\r\n          'User-Agent': this.config.defaultUserAgent,\r\n          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,text/plain;q=0.8,*/*;q=0.7',\r\n          'Accept-Language': 'en-US,en;q=0.9',\r\n          'Accept-Encoding': 'gzip, deflate',\r\n          'DNT': '1', // Do Not Track\r\n          'Connection': 'keep-alive',\r\n          'Upgrade-Insecure-Requests': '1'\r\n        }\r\n      });\r\n    } else {\r\n      console.log('­ƒîÉ WebFetchTool: Running in mock mode');\r\n      // Create dummy client for mock mode\r\n      this.client = axios.create();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch content from a URL with full content extraction\r\n   */\r\n  async fetchContent(options: WebFetchOptions): Promise<WebFetchResponse> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      if (this.mockMode) {\r\n        return this.mockFetch(options);\r\n      }\r\n\r\n      // Validate URL if requested\r\n      if (options.validateUrl !== false) {\r\n        this.validateUrl(options.url);\r\n      }\r\n\r\n      // Enforce rate limiting\r\n      await this.enforceRateLimit();\r\n\r\n      console.log(`­ƒîÉ WebFetchTool: Fetching content from ${options.url}`);\r\n\r\n      // Configure request options\r\n      const requestConfig = {\r\n        timeout: options.timeout || this.config.defaultTimeout,\r\n        maxRedirects: options.maxRedirects || 5,\r\n        ...(options.userAgent && { \r\n          headers: { 'User-Agent': options.userAgent } \r\n        })\r\n      };\r\n\r\n      const response: AxiosResponse = await this.client.get(options.url, requestConfig);\r\n      \r\n      // Check content size\r\n      const contentLength = response.headers['content-length'];\r\n      if (contentLength && parseInt(contentLength) > this.config.maxContentSize) {\r\n        throw new Error(`Content too large: ${contentLength} bytes (max: ${this.config.maxContentSize})`);\r\n      }\r\n\r\n      // Check content type\r\n      const contentType = response.headers['content-type'] || 'text/plain';\r\n      if (!this.isAllowedContentType(contentType)) {\r\n        console.warn(`ÔÜá´©Å Content type ${contentType} not in allowed list, proceeding anyway`);\r\n      }\r\n\r\n      // Extract content\r\n      const content = await this.extractContent(response.data, contentType, options);\r\n      \r\n      // Extract metadata (only for HTML content)\r\n      const metadata = contentType.includes('text/html') && options.extractMetadata !== false\r\n        ? await this.extractMetadata(response.data, options.url, response.request?.responseURL)\r\n        : {};\r\n\r\n      const fetchTime = Date.now() - startTime;\r\n\r\n      const result: WebFetchResponse = {\r\n        url: options.url,\r\n        finalUrl: response.request?.responseURL || options.url,\r\n        statusCode: response.status,\r\n        statusText: response.statusText,\r\n        headers: this.normalizeHeaders(response.headers),\r\n        content,\r\n        metadata,\r\n        fetchTime,\r\n        timestamp: new Date().toISOString(),\r\n        success: true\r\n      };\r\n\r\n      console.log(`Ô£à WebFetchTool: Successfully fetched ${content.size} bytes in ${fetchTime}ms`);\r\n      return result;\r\n\r\n    } catch (error: unknown) {\r\n      const fetchTime = Date.now() - startTime;\r\n      console.error('ÔØî WebFetchTool error:', error instanceof Error ? error.message : 'Unknown error');\r\n      \r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      const axiosError = error as { \r\n        code?: string; \r\n        response?: { \r\n          status?: number; \r\n          statusText?: string; \r\n          data?: unknown; \r\n          headers?: unknown; \r\n        }; \r\n      };\r\n\r\n      const webFetchError: WebFetchError = {\r\n        code: axiosError.code || 'FETCH_ERROR',\r\n        message: errorMessage,\r\n        url: options.url\r\n      };\r\n      \r\n      if (axiosError.response?.status) {\r\n        webFetchError.statusCode = axiosError.response.status;\r\n      }\r\n      \r\n      if (axiosError.response?.data) {\r\n        webFetchError.details = axiosError.response.data;\r\n      }\r\n\r\n      return {\r\n        url: options.url,\r\n        statusCode: axiosError.response?.status || 0,\r\n        statusText: axiosError.response?.statusText || 'Error',\r\n        headers: axiosError.response ? this.normalizeHeaders(axiosError.response.headers) : {},\r\n        content: {\r\n          raw: '',\r\n          text: '',\r\n          contentType: 'text/plain',\r\n          encoding: 'utf-8',\r\n          size: 0\r\n        },\r\n        metadata: {},\r\n        fetchTime,\r\n        timestamp: new Date().toISOString(),\r\n        success: false,\r\n        error: webFetchError.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Quick fetch - simplified interface for common use cases\r\n   */\r\n  async quickFetch(url: string, extractContent: boolean = true): Promise<WebFetchResponse> {\r\n    return this.fetchContent({\r\n      url,\r\n      extractContent,\r\n      extractMetadata: extractContent\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch multiple URLs concurrently (with rate limiting)\r\n   */\r\n  async fetchMultiple(urls: string[], options?: Partial<WebFetchOptions>): Promise<WebFetchResponse[]> {\r\n    console.log(`­ƒîÉ WebFetchTool: Fetching ${urls.length} URLs concurrently`);\r\n    \r\n    const results: WebFetchResponse[] = [];\r\n    \r\n    // Process URLs in batches to respect rate limits\r\n    const batchSize = Math.min(3, urls.length);\r\n    for (let i = 0; i < urls.length; i += batchSize) {\r\n      const batch = urls.slice(i, i + batchSize);\r\n      const batchPromises = batch.map(url => \r\n        this.fetchContent({ url, ...options })\r\n      );\r\n      \r\n      const batchResults = await Promise.allSettled(batchPromises);\r\n      results.push(...batchResults.map(result => \r\n        result.status === 'fulfilled' ? result.value : this.createErrorResponse(\r\n          batch[batchResults.indexOf(result)], \r\n          result.reason\r\n        )\r\n      ));\r\n      \r\n      // Add delay between batches\r\n      if (i + batchSize < urls.length) {\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Test the web fetch functionality\r\n   */\r\n  async testFetch(): Promise<boolean> {\r\n    try {\r\n      console.log('­ƒîÉ Testing web fetch functionality...');\r\n      \r\n      const testResult = await this.quickFetch('https://httpbin.org/user-agent');\r\n      const isWorking = testResult.success && testResult.content.size > 0;\r\n      \r\n      if (isWorking) {\r\n        console.log('Ô£à Web fetch test passed');\r\n      } else {\r\n        console.log('ÔÜá´©Å Web fetch test failed or returned no content');\r\n      }\r\n      \r\n      return isWorking;\r\n    } catch (error) {\r\n      console.error('ÔØî Web fetch test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // PRIVATE HELPER METHODS\r\n\r\n  /**\r\n   * Validate URL format and security\r\n   */\r\n  private validateUrl(url: string): void {\r\n    try {\r\n      const urlObj = new URL(url);\r\n      \r\n      // Check protocol\r\n      if (!['http:', 'https:'].includes(urlObj.protocol)) {\r\n        throw new Error(`Unsupported protocol: ${urlObj.protocol}`);\r\n      }\r\n      \r\n      // Check for blocked domains\r\n      if (this.config.blockedDomains?.some(domain => \r\n        urlObj.hostname.includes(domain)\r\n      )) {\r\n        throw new Error(`Domain ${urlObj.hostname} is blocked`);\r\n      }\r\n      \r\n      // Prevent localhost access in production (security measure)\r\n      if (process.env.NODE_ENV === 'production' && \r\n          ['localhost', '127.0.0.1', '::1'].includes(urlObj.hostname)) {\r\n        throw new Error('Localhost access not allowed in production');\r\n      }\r\n      \r\n    } catch (error) {\r\n      if (error instanceof TypeError) {\r\n        throw new Error(`Invalid URL format: ${url}`);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce rate limiting\r\n   */\r\n  private async enforceRateLimit(): Promise<void> {\r\n    const now = Date.now();\r\n    const timeSinceLastRequest = now - this.lastRequestTime;\r\n    const minInterval = 1000 / (this.config.rateLimit?.requestsPerSecond || 2);\r\n    \r\n    if (timeSinceLastRequest < minInterval) {\r\n      const delay = minInterval - timeSinceLastRequest;\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n    \r\n    this.lastRequestTime = Date.now();\r\n    this.requestCount++;\r\n  }\r\n\r\n  /**\r\n   * Check if content type is allowed\r\n   */\r\n  private isAllowedContentType(contentType: string): boolean {\r\n    return this.config.allowedContentTypes.some(allowed => \r\n      contentType.toLowerCase().includes(allowed.toLowerCase())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Extract and clean content based on content type\r\n   */\r\n  private async extractContent(\r\n    rawContent: string, \r\n    contentType: string, \r\n    options: WebFetchOptions\r\n  ): Promise<WebFetchContent> {\r\n    if (options.extractContent === false) {\r\n      return {\r\n        raw: rawContent,\r\n        text: rawContent,\r\n        contentType,\r\n        encoding: 'utf-8',\r\n        size: Buffer.byteLength(rawContent, 'utf8')\r\n      };\r\n    }\r\n\r\n    let cleanText = rawContent;\r\n    let cleanHtml: string | undefined;\r\n    let wordCount: number | undefined;\r\n\r\n    // HTML content extraction\r\n    if (contentType.includes('text/html')) {\r\n      try {\r\n        const dom = new JSDOM(rawContent);\r\n        const document = dom.window.document;\r\n        \r\n        // Remove script and style elements\r\n        const scriptsAndStyles = document.querySelectorAll('script, style, noscript');\r\n        scriptsAndStyles.forEach(element => element.remove());\r\n        \r\n        // Extract clean text\r\n        cleanText = document.body?.textContent || document.textContent || '';\r\n        cleanText = cleanText.replace(/\\s+/g, ' ').trim();\r\n        \r\n        // Keep cleaned HTML\r\n        cleanHtml = document.body?.innerHTML || document.documentElement.innerHTML;\r\n        \r\n        wordCount = cleanText.split(/\\s+/).filter(word => word.length > 0).length;\r\n        \r\n      } catch {\r\n        console.warn('ÔÜá´©Å HTML parsing failed, using raw content');\r\n        cleanText = rawContent.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\r\n      }\r\n    }\r\n    \r\n    // JSON content\r\n    else if (contentType.includes('application/json')) {\r\n      try {\r\n        const jsonData = JSON.parse(rawContent);\r\n        cleanText = JSON.stringify(jsonData, null, 2);\r\n      } catch (error) {\r\n        console.warn('ÔÜá´©Å JSON parsing failed, using raw content');\r\n      }\r\n    }\r\n    \r\n    // XML content  \r\n    else if (contentType.includes('xml')) {\r\n      // Basic XML cleaning - remove tags for text extraction\r\n      cleanText = rawContent.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\r\n    }    return {\r\n      raw: rawContent,\r\n      text: cleanText,\r\n      ...(cleanHtml && { html: cleanHtml }),\r\n      contentType,\r\n      encoding: 'utf-8', // Assume UTF-8 for now\r\n      size: Buffer.byteLength(rawContent, 'utf8'),\r\n      ...(wordCount && { wordCount })\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract metadata from HTML content\r\n   */\r\n  private async extractMetadata(\r\n    htmlContent: string, \r\n    originalUrl: string, \r\n    finalUrl?: string\r\n  ): Promise<WebFetchMetadata> {\r\n    try {\r\n      const dom = new JSDOM(htmlContent);\r\n      const document = dom.window.document;\r\n        const metadata: WebFetchMetadata = {};\r\n      \r\n      // Basic metadata - only assign if value exists\r\n      const title = document.querySelector('title')?.textContent?.trim();\r\n      if (title) metadata.title = title;\r\n      \r\n      const description = this.getMetaContent(document, 'description');\r\n      if (description) metadata.description = description;\r\n      \r\n      const keywordsRaw = this.getMetaContent(document, 'keywords');\r\n      if (keywordsRaw) metadata.keywords = keywordsRaw.split(',').map(k => k.trim());\r\n      \r\n      const author = this.getMetaContent(document, 'author');\r\n      if (author) metadata.author = author;\r\n      \r\n      const language = document.documentElement.lang || this.getMetaContent(document, 'language');\r\n      if (language) metadata.language = language;\r\n      \r\n      const canonical = document.querySelector('link[rel=\"canonical\"]')?.getAttribute('href');\r\n      if (canonical) metadata.canonical = canonical;\r\n      \r\n      const robots = this.getMetaContent(document, 'robots');\r\n      if (robots) metadata.robots = robots;\r\n      \r\n      const viewport = this.getMetaContent(document, 'viewport');\r\n      if (viewport) metadata.viewport = viewport;\r\n      \r\n      // Open Graph metadata\r\n      const ogTitle = this.getMetaProperty(document, 'og:title');\r\n      if (ogTitle) metadata.ogTitle = ogTitle;\r\n      \r\n      const ogDescription = this.getMetaProperty(document, 'og:description');\r\n      if (ogDescription) metadata.ogDescription = ogDescription;\r\n      \r\n      const ogImage = this.getMetaProperty(document, 'og:image');\r\n      if (ogImage) metadata.ogImage = ogImage;\r\n      \r\n      const ogUrl = this.getMetaProperty(document, 'og:url');\r\n      if (ogUrl) metadata.ogUrl = ogUrl;\r\n      \r\n      const ogType = this.getMetaProperty(document, 'og:type');\r\n      if (ogType) metadata.ogType = ogType;\r\n      \r\n      const ogSiteName = this.getMetaProperty(document, 'og:site_name');\r\n      if (ogSiteName) metadata.ogSiteName = ogSiteName;\r\n      \r\n      // Twitter Card metadata\r\n      const twitterCard = this.getMetaName(document, 'twitter:card');\r\n      if (twitterCard) metadata.twitterCard = twitterCard;\r\n      \r\n      const twitterTitle = this.getMetaName(document, 'twitter:title');\r\n      if (twitterTitle) metadata.twitterTitle = twitterTitle;\r\n      \r\n      const twitterDescription = this.getMetaName(document, 'twitter:description');\r\n      if (twitterDescription) metadata.twitterDescription = twitterDescription;\r\n      \r\n      const twitterImage = this.getMetaName(document, 'twitter:image');\r\n      if (twitterImage) metadata.twitterImage = twitterImage;\r\n      \r\n      const twitterSite = this.getMetaName(document, 'twitter:site');\r\n      if (twitterSite) metadata.twitterSite = twitterSite;\r\n      \r\n      // Additional metadata\r\n      const favicon = this.extractFavicon(document, finalUrl || originalUrl);\r\n      if (favicon) metadata.favicon = favicon;\r\n      \r\n      const generator = this.getMetaContent(document, 'generator');\r\n      if (generator) metadata.generator = generator;\r\n      \r\n      const lastModified = this.getMetaContent(document, 'last-modified');\r\n      if (lastModified) metadata.lastModified = lastModified;\r\n      \r\n      const publishedTime = this.getMetaProperty(document, 'article:published_time');\r\n      if (publishedTime) metadata.publishedTime = publishedTime;\r\n      \r\n      const modifiedTime = this.getMetaProperty(document, 'article:modified_time');\r\n      if (modifiedTime) metadata.modifiedTime = modifiedTime;\r\n      \r\n      // Extract images and links\r\n      metadata.images = this.extractImages(document, finalUrl || originalUrl);\r\n      metadata.links = this.extractLinks(document, finalUrl || originalUrl);\r\n      \r\n      return metadata;\r\n      \r\n    } catch (error) {\r\n      console.warn('ÔÜá´©Å Metadata extraction failed:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get meta content by name\r\n   */\r\n  private getMetaContent(document: Document, name: string): string | undefined {\r\n    return document.querySelector(`meta[name=\"${name}\"]`)?.getAttribute('content') || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get meta content by property (for Open Graph)\r\n   */\r\n  private getMetaProperty(document: Document, property: string): string | undefined {\r\n    return document.querySelector(`meta[property=\"${property}\"]`)?.getAttribute('content') || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get meta content by name attribute (for Twitter Cards)\r\n   */\r\n  private getMetaName(document: Document, name: string): string | undefined {\r\n    return document.querySelector(`meta[name=\"${name}\"]`)?.getAttribute('content') || undefined;\r\n  }\r\n\r\n  /**\r\n   * Extract favicon URL\r\n   */\r\n  private extractFavicon(document: Document, baseUrl: string): string | undefined {\r\n    const selectors = [\r\n      'link[rel=\"icon\"]',\r\n      'link[rel=\"shortcut icon\"]', \r\n      'link[rel=\"apple-touch-icon\"]'\r\n    ];\r\n    \r\n    for (const selector of selectors) {\r\n      const link = document.querySelector(selector);\r\n      if (link) {\r\n        const href = link.getAttribute('href');\r\n        if (href) {\r\n          return this.resolveUrl(href, baseUrl);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Default favicon location\r\n    try {\r\n      const url = new URL(baseUrl);\r\n      return `${url.protocol}//${url.host}/favicon.ico`;\r\n    } catch {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract image URLs from page\r\n   */\r\n  private extractImages(document: Document, baseUrl: string): string[] {\r\n    const images = Array.from(document.querySelectorAll('img[src]'));\r\n    return images\r\n      .map(img => img.getAttribute('src'))\r\n      .filter((src): src is string => !!src)\r\n      .map(src => this.resolveUrl(src, baseUrl))\r\n      .slice(0, 20); // Limit to first 20 images\r\n  }\r\n\r\n  /**\r\n   * Extract link URLs from page\r\n   */\r\n  private extractLinks(document: Document, baseUrl: string): string[] {\r\n    const links = Array.from(document.querySelectorAll('a[href]'));\r\n    return links\r\n      .map(link => link.getAttribute('href'))\r\n      .filter((href): href is string => !!href)\r\n      .filter(href => href.startsWith('http') || href.startsWith('/'))\r\n      .map(href => this.resolveUrl(href, baseUrl))\r\n      .slice(0, 50); // Limit to first 50 links\r\n  }\r\n\r\n  /**\r\n   * Resolve relative URLs to absolute URLs\r\n   */\r\n  private resolveUrl(url: string, baseUrl: string): string {\r\n    try {\r\n      return new URL(url, baseUrl).href;\r\n    } catch {\r\n      return url;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize response headers\r\n   */\r\n  private normalizeHeaders(headers: unknown): Record<string, string> {\r\n    const normalized: Record<string, string> = {};\r\n    if (headers && typeof headers === 'object') {\r\n      for (const [key, value] of Object.entries(headers)) {\r\n        if (typeof value === 'string') {\r\n          normalized[key.toLowerCase()] = value;\r\n        }\r\n      }\r\n    }\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Create error response\r\n   */\r\n  private createErrorResponse(url: string, error: unknown): WebFetchResponse {\r\n    return {\r\n      url,\r\n      statusCode: 0,\r\n      statusText: 'Error',\r\n      headers: {},\r\n      content: {\r\n        raw: '',\r\n        text: '',\r\n        contentType: 'text/plain',\r\n        encoding: 'utf-8',\r\n        size: 0\r\n      },\r\n      metadata: {},\r\n      fetchTime: 0,\r\n      timestamp: new Date().toISOString(),\r\n      success: false,\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mock fetch implementation for development/testing\r\n   */\r\n  private mockFetch(options: WebFetchOptions): WebFetchResponse {\r\n    console.log(`­ƒîÉ Mock fetch for: ${options.url}`);\r\n    \r\n    const mockHtml = `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <meta name=\"description\" content=\"Mock webpage content for OneAgent WebFetchTool testing\">\r\n    <meta property=\"og:title\" content=\"Mock Page Title\">\r\n    <meta property=\"og:description\" content=\"Mock webpage for testing WebFetchTool functionality\">\r\n    <title>Mock Page Title - OneAgent Test</title>\r\n</head>\r\n<body>\r\n    <h1>Mock Page Content</h1>\r\n    <p>This is mock content returned by WebFetchTool for URL: ${options.url}</p>\r\n    <p>In production, this would be real webpage content fetched from the actual URL.</p>\r\n    <a href=\"https://example.com/link1\">Mock Link 1</a>\r\n    <a href=\"https://example.com/link2\">Mock Link 2</a>\r\n    <img src=\"https://example.com/image1.jpg\" alt=\"Mock Image 1\">\r\n</body>\r\n</html>`;\r\n\r\n    const mockContent: WebFetchContent = {\r\n      raw: mockHtml,\r\n      text: 'Mock Page Content This is mock content returned by WebFetchTool for URL: ' + options.url + ' In production, this would be real webpage content fetched from the actual URL.',\r\n      html: '<h1>Mock Page Content</h1><p>This is mock content returned by WebFetchTool for URL: ' + options.url + '</p><p>In production, this would be real webpage content fetched from the actual URL.</p><a href=\"https://example.com/link1\">Mock Link 1</a><a href=\"https://example.com/link2\">Mock Link 2</a><img src=\"https://example.com/image1.jpg\" alt=\"Mock Image 1\">',\r\n      contentType: 'text/html',\r\n      encoding: 'utf-8',\r\n      size: mockHtml.length,\r\n      wordCount: 25\r\n    };\r\n\r\n    const mockMetadata: WebFetchMetadata = {\r\n      title: 'Mock Page Title - OneAgent Test',\r\n      description: 'Mock webpage content for OneAgent WebFetchTool testing',\r\n      language: 'en',\r\n      ogTitle: 'Mock Page Title',\r\n      ogDescription: 'Mock webpage for testing WebFetchTool functionality',\r\n      images: ['https://example.com/image1.jpg'],\r\n      links: ['https://example.com/link1', 'https://example.com/link2']\r\n    };\r\n\r\n    return {\r\n      url: options.url,\r\n      finalUrl: options.url,\r\n      statusCode: 200,\r\n      statusText: 'OK',\r\n      headers: {\r\n        'content-type': 'text/html; charset=utf-8',\r\n        'content-length': mockHtml.length.toString()\r\n      },\r\n      content: mockContent,\r\n      metadata: mockMetadata,\r\n      fetchTime: 150, // Mock 150ms fetch time\r\n      timestamp: new Date().toISOString(),\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get tool configuration\r\n   */\r\n  getConfig() {\r\n    return {\r\n      provider: 'WebFetch',\r\n      mockMode: this.mockMode,\r\n      config: {\r\n        ...this.config,\r\n        // Don't expose sensitive data\r\n        defaultUserAgent: this.config.defaultUserAgent\r\n      }\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\webSearch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
