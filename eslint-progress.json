[{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\CodeAnalysisTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\ConversationRetrievalTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\ConversationSearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\EnhancedAIAssistantTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\EnhancedSearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemoryAddTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemoryDeleteTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemoryEditTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\OneAgentMemorySearchTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\SmartGeminiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\SystemHealthTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\ToolRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedContext7QueryTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedContext7StoreTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedMCPTool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedWebFetchTool.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":206,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6559,6562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6559,6562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6573,6576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6573,6576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":273,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8346,8349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8346,8349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9166,9169],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9166,9169],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":305,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":305,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9222,9225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9222,9225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":341,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10554,10557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10554,10557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":363,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":363,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Unified Web Fetch Tool\r\n * Constitutional AI-compliant wrapper for WebFetchTool\r\n */\r\n\r\nimport { UnifiedMCPTool, ToolExecutionResult, InputSchema } from './UnifiedMCPTool';\r\nimport { WebFetchTool } from './webFetch';\r\nimport { OneAgentMemory, OneAgentMemoryConfig } from '../memory/OneAgentMemory';\r\n\r\nexport interface WebFetchParams {\r\n  url: string;\r\n  extractContent?: boolean;\r\n  includeMetadata?: boolean;\r\n  timeout?: number;\r\n  userAgent?: string;\r\n  validateUrl?: boolean;\r\n}\r\n\r\nexport interface FetchLearning {\r\n  id: string;\r\n  agentId: string;\r\n  learningType: string;\r\n  content: string;\r\n  confidence: number;\r\n  applicationCount: number;\r\n  lastApplied: Date;\r\n  sourceConversations: unknown[];\r\n  metadata: {\r\n    tool: string;\r\n    operation: string;\r\n    domain?: string;\r\n  };\r\n}\r\n\r\nexport class UnifiedWebFetchTool extends UnifiedMCPTool {\r\n  private webFetchTool: WebFetchTool;\r\n  private memorySystem: OneAgentMemory;\r\n\r\n  constructor() {\r\n    const schema: InputSchema = {\r\n      type: 'object',\r\n      properties: {\r\n        url: { \r\n          type: 'string', \r\n          description: 'URL to fetch content from',\r\n          pattern: '^https?://.+'\r\n        },\r\n        extractContent: { \r\n          type: 'boolean', \r\n          description: 'Extract main content from HTML (default: true)' \r\n        },\r\n        includeMetadata: { \r\n          type: 'boolean', \r\n          description: 'Include page metadata (default: true)' \r\n        },\r\n        timeout: { \r\n          type: 'number', \r\n          description: 'Request timeout in milliseconds (default: 10000)',\r\n          minimum: 1000,\r\n          maximum: 30000\r\n        },\r\n        userAgent: { \r\n          type: 'string', \r\n          description: 'Custom User-Agent string' \r\n        },\r\n        validateUrl: { \r\n          type: 'boolean', \r\n          description: 'Validate URL before fetching (default: true)' \r\n        }\r\n      },\r\n      required: ['url']\r\n    };\r\n\r\n    super(\r\n      'oneagent_web_fetch',\r\n      'Fetch and extract content from web pages with Constitutional AI validation',\r\n      schema,\r\n      'enhanced'\r\n    );\r\n\r\n    // Initialize WebFetchTool\r\n    this.webFetchTool = new WebFetchTool({\r\n      defaultTimeout: 10000,\r\n      defaultUserAgent: 'OneAgent-WebFetchTool/1.0 (Constitutional AI Compliant)',\r\n      maxRetries: 3,\r\n      retryDelay: 1000,\r\n      maxContentSize: 10 * 1024 * 1024, // 10MB\r\n      allowedContentTypes: [\r\n        'text/html',\r\n        'text/plain',\r\n        'text/xml',\r\n        'application/xml',\r\n        'application/json',\r\n        'text/markdown'\r\n      ]\r\n    });\r\n    const memoryConfig: OneAgentMemoryConfig = {\r\n      apiKey: process.env.MEM0_API_KEY || 'demo-key',\r\n      apiUrl: process.env.MEM0_API_URL\r\n    };\r\n    this.memorySystem = new OneAgentMemory(memoryConfig);\r\n  }\r\n\r\n  public async executeCore(args: unknown): Promise<ToolExecutionResult> {\r\n    try {\r\n      const params = args as WebFetchParams;\r\n      const { \r\n        url, \r\n        extractContent = true, \r\n        includeMetadata = true, \r\n        timeout = 10000,\r\n        userAgent,\r\n        validateUrl = true\r\n      } = params;\r\n\r\n      // Constitutional AI URL validation\r\n      const urlValidation = this.validateUrlSafety(url);\r\n      if (!urlValidation.isValid) {\r\n        return {\r\n          success: false,\r\n          data: {\r\n            success: false,\r\n            message: `URL validation failed: ${urlValidation.reason}`,\r\n            url,\r\n            timestamp: new Date().toISOString()\r\n          }\r\n        };\r\n      }      // Fetch content using WebFetchTool\r\n      const fetchResult = await this.webFetchTool.fetchContent({\r\n        url,\r\n        extractContent,\r\n        extractMetadata: includeMetadata,\r\n        timeout,\r\n        userAgent,\r\n        validateUrl\r\n      });\r\n\r\n      // Apply Constitutional AI content filtering\r\n      const filteredContent = await this.applyContentFiltering(fetchResult);\r\n      \r\n      // Store fetch learning in memory\r\n      await this.storeFetchLearning(url, filteredContent);\r\n\r\n      return {\r\n        success: true,\r\n        data: {\r\n          success: true,\r\n          fetchResult: filteredContent,\r\n          url,\r\n          contentExtracted: extractContent,\r\n          metadataIncluded: includeMetadata,\r\n          constitutionallyValidated: true,\r\n          message: 'Web content fetched with Constitutional AI validation',\r\n          capabilities: [\r\n            'Web content fetching and extraction',\r\n            'Constitutional AI content filtering',\r\n            'Safe URL validation',\r\n            'Metadata extraction and analysis'\r\n          ],\r\n          qualityScore: this.calculateContentQuality(filteredContent),\r\n          toolName: 'oneagent_web_fetch',\r\n          constitutionalCompliant: true,\r\n          timestamp: new Date().toISOString(),\r\n          metadata: {\r\n            fetchType: 'web_content',\r\n            toolFramework: 'unified_mcp_v1.0',\r\n            constitutionalLevel: 'enhanced'\r\n          }\r\n        }\r\n      };\r\n\r\n    } catch (_error) {\r\n      return {\r\n        success: false,\r\n        data: _error instanceof Error ? _error.message : 'Web fetch failed',\r\n        qualityScore: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate URL safety using Constitutional AI principles\r\n   */\r\n  private validateUrlSafety(url: string): { isValid: boolean; reason?: string } {\r\n    try {\r\n      const urlObj = new URL(url);\r\n      \r\n      // Block potentially harmful protocols\r\n      if (!['http:', 'https:'].includes(urlObj.protocol)) {\r\n        return { isValid: false, reason: 'Only HTTP/HTTPS protocols allowed' };\r\n      }\r\n      \r\n      // Block localhost and private IPs for security\r\n      const hostname = urlObj.hostname.toLowerCase();\r\n      if (hostname === 'localhost' || hostname.startsWith('127.') || hostname.startsWith('192.168.') || hostname.startsWith('10.')) {\r\n        return { isValid: false, reason: 'Private/localhost URLs not allowed' };\r\n      }\r\n      \r\n      // Block potentially malicious file extensions\r\n      const maliciousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.pif', '.com'];\r\n      if (maliciousExtensions.some(ext => urlObj.pathname.toLowerCase().endsWith(ext))) {\r\n        return { isValid: false, reason: 'Potentially unsafe file type' };\r\n      }\r\n      \r\n      return { isValid: true };\r\n    } catch (error) {\r\n      return { isValid: false, reason: 'Invalid URL format' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply Constitutional AI content filtering\r\n   */\r\n  private async applyContentFiltering(fetchResult: any): Promise<any> {\r\n    if (!fetchResult.success || !fetchResult.content) {\r\n      return fetchResult;\r\n    }\r\n\r\n    // Filter potentially harmful content patterns\r\n    const harmfulPatterns = [\r\n      /\\b(download.*virus|malware|trojan)\\b/gi,\r\n      /\\b(hack.*password|steal.*data|phishing)\\b/gi,\r\n      /\\b(illegal.*download|piracy|torrent)\\b/gi\r\n    ];\r\n\r\n    const contentWarnings: string[] = [];\r\n    const content = fetchResult.content.text || '';\r\n    \r\n    harmfulPatterns.forEach((pattern, index) => {\r\n      if (pattern.test(content)) {\r\n        contentWarnings.push(`Potential security concern detected (pattern ${index + 1})`);\r\n      }\r\n    });\r\n\r\n    return {\r\n      ...fetchResult,\r\n      content: {\r\n        ...fetchResult.content,\r\n        safetyScore: this.calculateSafetyScore(content),\r\n        contentWarnings: contentWarnings.length > 0 ? contentWarnings : undefined\r\n      },\r\n      constitutionalValidation: {\r\n        passed: contentWarnings.length === 0,\r\n        warnings: contentWarnings,\r\n        safetyScore: this.calculateSafetyScore(content)\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate content safety score\r\n   */\r\n  private calculateSafetyScore(content: string): number {\r\n    let score = 100;\r\n    \r\n    const riskyTerms = [\r\n      'virus', 'malware', 'hack', 'exploit', 'phishing',\r\n      'illegal', 'piracy', 'crack', 'keygen', 'warez'\r\n    ];\r\n    \r\n    const contentLower = content.toLowerCase();\r\n    riskyTerms.forEach(term => {\r\n      const matches = (contentLower.match(new RegExp(term, 'g')) || []).length;\r\n      score -= matches * 5; // Reduce score for each risky term occurrence\r\n    });\r\n    \r\n    return Math.max(score, 0);\r\n  }\r\n\r\n  /**\r\n   * Calculate overall content quality\r\n   */\r\n  private calculateContentQuality(fetchResult: any): number {\r\n    if (!fetchResult.success) return 0;\r\n    \r\n    let score = 50; // Base score\r\n    \r\n    // Boost for successful content extraction\r\n    if (fetchResult.content && fetchResult.content.text) {\r\n      score += 20;\r\n      \r\n      // Boost for substantial content\r\n      if (fetchResult.content.text.length > 1000) {\r\n        score += 15;\r\n      }\r\n    }\r\n    \r\n    // Boost for metadata availability\r\n    if (fetchResult.content && fetchResult.content.metadata) {\r\n      score += 10;\r\n    }\r\n    \r\n    // Apply safety score\r\n    const safetyScore = fetchResult.content?.safetyScore || 100;\r\n    score = score * (safetyScore / 100);\r\n    \r\n    return Math.min(Math.round(score), 100);\r\n  }\r\n\r\n  /**\r\n   * Store fetch learning in memory\r\n   */\r\n  private async storeFetchLearning(url: string, fetchResult: any): Promise<void> {\r\n    try {\r\n      const learning: any = {\r\n        id: `learning_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n        agentId: 'oneagent_web_fetch',\r\n        learningType: 'documentation_context',\r\n        content: JSON.stringify({\r\n          url,\r\n          success: fetchResult.success,\r\n          contentLength: fetchResult.content?.text?.length || 0,\r\n          safetyScore: fetchResult.content?.safetyScore || 0,\r\n          qualityScore: this.calculateContentQuality(fetchResult),\r\n          fetchTime: fetchResult.timing?.totalTime || 0,\r\n          timestamp: new Date().toISOString(),\r\n          insights: this.generateFetchInsights(url, fetchResult)\r\n        }),\r\n        confidence: 0.9,\r\n        applicationCount: 0,\r\n        lastApplied: new Date(),\r\n        sourceConversations: [],\r\n        metadata: {\r\n          tool: 'web_fetch',\r\n          operation: 'web_content_fetch',\r\n          domain: (() => { try { return new URL(url).hostname; } catch { return undefined; } })(),\r\n        }\r\n      };\r\n      await this.memorySystem.addMemory({\r\n        ...learning,\r\n        type: 'learnings'\r\n      });\r\n    } catch (error) {\r\n      console.warn('[UnifiedWebFetchTool] Failed to store fetch learning:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate insights from fetch results\r\n   */\r\n  private generateFetchInsights(url: string, fetchResult: any): string[] {\r\n    const insights: string[] = [];\r\n    \r\n    if (!fetchResult.success) {\r\n      insights.push('Fetch failed - check URL accessibility and network connectivity');\r\n    } else {\r\n      const contentLength = fetchResult.content?.text?.length || 0;\r\n      if (contentLength < 100) {\r\n        insights.push('Very short content - may indicate redirection or minimal page');\r\n      } else if (contentLength > 50000) {\r\n        insights.push('Large content detected - consider content summarization');\r\n      }\r\n      \r\n      const safetyScore = fetchResult.content?.safetyScore || 100;\r\n      if (safetyScore < 80) {\r\n        insights.push('Safety concerns detected - review content before use');\r\n      }\r\n    }\r\n    \r\n    try {\r\n      const domain = new URL(url).hostname;\r\n      insights.push(`Domain: ${domain} - consider adding to trusted/blocked list based on quality`);\r\n    } catch (error) {\r\n      insights.push('URL parsing failed - validate URL format');\r\n    }\r\n    \r\n    return insights;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\UnifiedWebSearchTool.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1744,1747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1744,1747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filteredResults' is assigned a value but never used.","line":73,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3754,3757],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3754,3757],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3771,3774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3771,3774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Unified Web Search Tool\r\n * Constitutional AI compliant web search with quality filtering\r\n */\r\n\r\nimport { UnifiedMCPTool, ToolExecutionResult, InputSchema } from './UnifiedMCPTool';\r\nimport { WebSearchTool, WebSearchOptions } from './webSearch';\r\nimport { BraveSearchClient } from './braveSearchClient';\r\nimport { oneAgentConfig } from '../config/index';\r\n\r\nexport class UnifiedWebSearchTool extends UnifiedMCPTool {\r\n  private webSearchTool: WebSearchTool;\r\n\r\n  constructor() {\r\n    const schema: InputSchema = {\r\n      type: 'object',\r\n      properties: {\r\n        query: { \r\n          type: 'string', \r\n          description: 'Search query for web content' \r\n        },\r\n        maxResults: { \r\n          type: 'number', \r\n          description: 'Maximum number of results (default: 5)' \r\n        },\r\n        qualityThreshold: { \r\n          type: 'number', \r\n          description: 'Minimum quality score for results (0-100, default: 80)' \r\n        },\r\n        safesearch: { \r\n          type: 'string', \r\n          enum: ['strict', 'moderate', 'off'],\r\n          description: 'Safe search setting (default: moderate)' \r\n        }\r\n      },\r\n      required: ['query']\r\n    };\r\n\r\n    super(\r\n      'oneagent_web_search',\r\n      'Web search with quality filtering and Constitutional AI validation',\r\n      schema,\r\n      'enhanced'\r\n    );    // Initialize with proper Brave client using centralized config\r\n    const braveClient = new BraveSearchClient({\r\n      apiKey: oneAgentConfig.braveApiKey || 'mock_mode',\r\n      baseUrl: 'https://api.search.brave.com/res/v1/web/search',\r\n      timeout: 10000,\r\n      retryAttempts: 3\r\n    });\r\n    this.webSearchTool = new WebSearchTool(braveClient);\r\n  }\r\n\r\n  public async executeCore(args: any): Promise<ToolExecutionResult> {\r\n    try {\r\n      const { \r\n        query, \r\n        maxResults = 5, \r\n        qualityThreshold = 80,\r\n        safesearch = 'moderate'\r\n      } = args;\r\n\r\n      const searchOptions: WebSearchOptions = {\r\n        query,\r\n        count: maxResults,\r\n        safesearch,\r\n        includeRecent: true\r\n      };\r\n\r\n      const searchResults = await this.webSearchTool.search(searchOptions);\r\n\r\n      // Apply quality filtering\r\n      const filteredResults = searchResults.results.filter(result => {\r\n        // Basic quality scoring based on title/description completeness\r\n        let score = 0;\r\n        if (result.title && result.title.length > 10) score += 30;\r\n        if (result.description && result.description.length > 50) score += 40;\r\n        if (result.url && result.url.includes('https://')) score += 20;\r\n        if (result.age && !result.age.includes('years ago')) score += 10;\r\n        \r\n        return score >= qualityThreshold;\r\n      });      return {\r\n        success: true,\r\n        data: {\r\n          success: true,\r\n          searchResults,\r\n          query,\r\n          qualityThreshold,\r\n          maxResults,\r\n          message: 'Enhanced search completed with quality filtering',\r\n          capabilities: [\r\n            'Constitutional AI content validation',\r\n            'Quality-based result filtering',\r\n            'Source preference handling',\r\n            'Real-time result scoring'\r\n          ],\r\n          qualityScore: 95,\r\n          toolName: 'oneagent_enhanced_search',\r\n          constitutionalCompliant: true,\r\n          timestamp: new Date().toISOString(),\r\n          searchType: 'enhanced_web',\r\n          toolFramework: 'unified_mcp_v1.0',\r\n          constitutionalLevel: 'critical'\r\n        }\r\n      };    } catch (error) {\r\n      return {\r\n        success: false,\r\n        data: error instanceof Error ? error.message : 'Web search failed',\r\n        qualityScore: 0\r\n      };\r\n    }\r\n  }\r\n\r\n  private calculateQualityScore(filtered: any[], original: any[]): number {\r\n    if (original.length === 0) return 0;\r\n    \r\n    const filterRatio = filtered.length / original.length;\r\n    const baseScore = Math.min(filtered.length * 15, 75); // Up to 75 for results count\r\n    const qualityBonus = filterRatio > 0.8 ? 25 : filterRatio > 0.5 ? 15 : 5;\r\n    \r\n    return Math.min(baseScore + qualityBonus, 100);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\aiAssistant.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1983,1986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1983,1986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'instruction' is assigned a value but never used.","line":100,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":116,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3723,3726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3723,3726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5013,5016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5013,5016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// AI Assistant tool using Google Gemini for intelligent text processing\r\n\r\nimport { GeminiClient } from './geminiClient';\r\nimport { ChatResponse, ChatOptions } from '../types/gemini';\r\n\r\nexport interface AIAssistantOptions {\r\n  temperature?: number;\r\n  maxTokens?: number;\r\n  context?: string;\r\n  format?: 'text' | 'json' | 'markdown';\r\n}\r\n\r\nexport interface AITaskResult {\r\n  success: boolean;\r\n  result: string;\r\n  confidence?: number;\r\n  processingTime: number;\r\n  timestamp: string;\r\n  error?: string;\r\n}\r\n\r\nexport class AIAssistantTool {\r\n  private geminiClient: GeminiClient;\r\n\r\n  constructor(geminiClient: GeminiClient) {\r\n    this.geminiClient = geminiClient;\r\n  }\r\n\r\n  /**\r\n   * Ask the AI assistant a question\r\n   */\r\n  async ask(question: string, options?: AIAssistantOptions): Promise<AITaskResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      console.log(`­ƒñû AI Assistant: Processing question \"${question.substring(0, 50)}...\"`);      const chatOptions: ChatOptions = {\r\n        temperature: options?.temperature || 0.7,\r\n        maxTokens: options?.maxTokens || 1000,\r\n        ...(options?.context && { context: options.context })\r\n      };\r\n\r\n      // Add format instructions if specified\r\n      let formattedQuestion = question;\r\n      if (options?.format === 'json') {\r\n        formattedQuestion += '\\n\\nPlease respond in valid JSON format.';\r\n      } else if (options?.format === 'markdown') {\r\n        formattedQuestion += '\\n\\nPlease format your response using Markdown.';\r\n      }\r\n\r\n      const response = await this.geminiClient.chat(formattedQuestion, chatOptions);\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      console.log(`­ƒñû AI Assistant: Response generated in ${processingTime}ms`);\r\n\r\n      return {\r\n        success: true,\r\n        result: response.response,\r\n        confidence: this.calculateConfidence(response),\r\n        processingTime,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n    } catch (error: any) {\r\n      const processingTime = Date.now() - startTime;\r\n      console.error('ÔØî AI Assistant error:', error.message);\r\n      \r\n      return {\r\n        success: false,\r\n        result: '',\r\n        processingTime,\r\n        timestamp: new Date().toISOString(),\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze and summarize text\r\n   */\r\n  async summarize(text: string, options?: { \r\n    maxLength?: number; \r\n    style?: 'brief' | 'detailed' | 'bullet-points' \r\n  }): Promise<AITaskResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      console.log(`­ƒñû AI Assistant: Summarizing ${text.length} characters`);\r\n\r\n      let instruction = 'Please provide a clear and concise summary of the following text';\r\n      \r\n      if (options?.maxLength) {\r\n        instruction += ` in approximately ${options.maxLength} words`;\r\n      }\r\n      \r\n      if (options?.style === 'bullet-points') {\r\n        instruction += ' using bullet points to highlight key information';\r\n      } else if (options?.style === 'detailed') {\r\n        instruction += ' with detailed analysis of main themes and important details';\r\n      } else if (options?.style === 'brief') {\r\n        instruction += ' focusing only on the most essential information';\r\n      }\r\n\r\n      const response = await this.geminiClient.summarizeText(text, options?.maxLength);\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      console.log(`­ƒñû AI Assistant: Summary completed in ${processingTime}ms`);\r\n\r\n      return {\r\n        success: true,\r\n        result: response.response,\r\n        confidence: this.calculateConfidence(response),\r\n        processingTime,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n    } catch (error: any) {\r\n      const processingTime = Date.now() - startTime;\r\n      console.error('ÔØî AI Assistant summarization error:', error.message);\r\n      \r\n      return {\r\n        success: false,\r\n        result: '',\r\n        processingTime,\r\n        timestamp: new Date().toISOString(),\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze text with specific instructions\r\n   */\r\n  async analyze(text: string, instruction: string, options?: AIAssistantOptions): Promise<AITaskResult> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      console.log(`­ƒñû AI Assistant: Analyzing text with instruction \"${instruction.substring(0, 30)}...\"`);      const response = await this.geminiClient.analyzeText(text, instruction, {\r\n        temperature: options?.temperature || 0.3,\r\n        maxTokens: options?.maxTokens || 1500,\r\n        ...(options?.context && { context: options.context })\r\n      });\r\n\r\n      const processingTime = Date.now() - startTime;\r\n\r\n      console.log(`­ƒñû AI Assistant: Analysis completed in ${processingTime}ms`);\r\n\r\n      return {\r\n        success: true,\r\n        result: response.response,\r\n        confidence: this.calculateConfidence(response),\r\n        processingTime,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n    } catch (error: any) {\r\n      const processingTime = Date.now() - startTime;\r\n      console.error('ÔØî AI Assistant analysis error:', error.message);\r\n      \r\n      return {\r\n        success: false,\r\n        result: '',\r\n        processingTime,\r\n        timestamp: new Date().toISOString(),\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Help with workflow tasks\r\n   */\r\n  async helpWithWorkflow(workflowName: string, currentStep: string, context: string): Promise<AITaskResult> {\r\n    const question = `I'm working on a workflow called \"${workflowName}\" and I'm currently at the step: \"${currentStep}\". \r\n    \r\nContext: ${context}\r\n\r\nCan you help me understand what I should do next or provide guidance for completing this step effectively?`;\r\n\r\n    return this.ask(question, {\r\n      temperature: 0.5,\r\n      maxTokens: 800,\r\n      format: 'markdown'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate workflow suggestions\r\n   */\r\n  async suggestWorkflowImprovements(workflowDescription: string): Promise<AITaskResult> {\r\n    const question = `Please analyze this workflow description and suggest improvements, optimizations, or potential issues:\r\n\r\n${workflowDescription}\r\n\r\nPlease provide specific, actionable suggestions.`;\r\n\r\n    return this.ask(question, {\r\n      temperature: 0.6,\r\n      maxTokens: 1000,\r\n      format: 'markdown'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Test the AI assistant functionality\r\n   */\r\n  async testAssistant(): Promise<boolean> {\r\n    try {\r\n      console.log('­ƒñû Testing AI assistant functionality...');\r\n      \r\n      const testResult = await this.ask('Please respond with \"AI Assistant test successful\" to confirm you are working correctly.', {\r\n        temperature: 0.1,\r\n        maxTokens: 50\r\n      });\r\n      \r\n      const isWorking = testResult.success && testResult.result.toLowerCase().includes('test successful');\r\n      \r\n      if (isWorking) {\r\n        console.log('Ô£à AI assistant test passed');\r\n      } else {\r\n        console.log('ÔÜá´©Å AI assistant test completed (mock mode)');\r\n      }\r\n      \r\n      return isWorking || testResult.success; // Allow mock mode to pass\r\n    } catch (error) {\r\n      console.error('ÔØî AI assistant test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence score based on response characteristics\r\n   */\r\n  private calculateConfidence(response: ChatResponse): number {\r\n    let confidence = 70; // Base confidence\r\n\r\n    // Increase confidence for longer, more detailed responses\r\n    if (response.response.length > 200) confidence += 10;\r\n    if (response.response.length > 500) confidence += 10;\r\n\r\n    // Increase confidence if response finished normally\r\n    if (response.finishReason === 'STOP') confidence += 10;\r\n\r\n    // Decrease confidence for very short responses\r\n    if (response.response.length < 50) confidence -= 20;\r\n\r\n    return Math.max(0, Math.min(100, confidence));\r\n  }\r\n\r\n  /**\r\n   * Get AI assistant configuration\r\n   */\r\n  getConfig() {\r\n    return {\r\n      provider: 'Google Gemini',\r\n      clientConfig: this.geminiClient.getConfig()\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\braveSearchClient.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3723,3726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3723,3726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4350,4353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4350,4353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// filepath: coreagent/tools/braveSearchClient.ts\r\n// Brave Search API client for web search capabilities\r\n\r\nimport axios, { AxiosInstance, AxiosResponse } from 'axios';\r\nimport { \r\n  BraveSearchQuery, \r\n  BraveSearchResponse, \r\n  BraveSearchResult, \r\n  BraveSearchConfig,\r\n  BraveSearchError \r\n} from '../types/braveSearch';\r\n\r\nexport class BraveSearchClient {\r\n  private client: AxiosInstance;\r\n  private config: BraveSearchConfig;\r\n  private mockMode: boolean = false;\r\n  private lastRequestTime: number = 0;\r\n  private requestCount: number = 0;\r\n  private monthlyRequestCount: number = 0;\r\n  private monthStart: number = Date.now();\r\n\r\n  constructor(config: BraveSearchConfig) {\r\n    this.config = {\r\n      baseUrl: 'https://api.search.brave.com/res/v1/web/search',\r\n      timeout: 10000,\r\n      retryAttempts: 3,\r\n      ...config\r\n    };    // Enable mock mode if no API key provided or in test environment\r\n    this.mockMode = !config.apiKey || config.apiKey === 'your_brave_search_api_key_here' || process.env.NODE_ENV === 'test';\r\n    \r\n    if (this.mockMode) {\r\n      console.log('­ƒöì BraveSearchClient: Running in fallback mode (DuckDuckGo) - Configure BRAVE_API_KEY for production');\r\n    }if (!this.mockMode) {\r\n      this.client = axios.create({\r\n        baseURL: this.config.baseUrl!,\r\n        timeout: this.config.timeout!,\r\n        headers: {\r\n          'X-Subscription-Token': this.config.apiKey,\r\n          'Accept': 'application/json',\r\n          'Accept-Encoding': 'gzip'\r\n        }\r\n      });\r\n    } else {\r\n      console.log('­ƒöì BraveSearchClient: Running in mock mode');\r\n      // Create a dummy client for mock mode\r\n      this.client = axios.create();\r\n    }\r\n  }\r\n  /**\r\n   * Ensure we respect rate limits (1 request per second, 2000 per month)\r\n   */\r\n  private async enforceRateLimit(): Promise<void> {\r\n    const now = Date.now();\r\n    \r\n    // Reset monthly counter if needed\r\n    if (now - this.monthStart > 30 * 24 * 60 * 60 * 1000) { // ~30 days\r\n      this.monthlyRequestCount = 0;\r\n      this.monthStart = now;\r\n    }\r\n    \r\n    // Check monthly limit\r\n    if (this.monthlyRequestCount >= 2000) {\r\n      console.warn('­ƒÜ½ Monthly Brave Search limit (2000) reached. Switching to mock mode.');\r\n      this.mockMode = true;\r\n      return;\r\n    }\r\n    \r\n    // Enforce 1 request per second limit\r\n    const timeSinceLastRequest = now - this.lastRequestTime;\r\n    if (timeSinceLastRequest < 1000) {\r\n      const delay = 1000 - timeSinceLastRequest;\r\n      console.log(`ÔÅ│ Rate limiting: waiting ${delay}ms before next request`);\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n    \r\n    this.lastRequestTime = Date.now();\r\n    this.monthlyRequestCount++;\r\n  }\r\n\r\n  /**\r\n   * Perform a web search using Brave Search API\r\n   */  async search(query: BraveSearchQuery): Promise<BraveSearchResult[]> {\r\n    try {\r\n      if (this.mockMode) {\r\n        return this.mockSearch(query);\r\n      }\r\n\r\n      // Enforce rate limiting before making request\r\n      await this.enforceRateLimit();\r\n\r\n      console.log(`­ƒöì Searching for: \"${query.q}\"`);\r\n\r\n      const params = {\r\n        q: query.q,\r\n        count: query.count || 10,\r\n        offset: query.offset || 0,\r\n        safesearch: query.safesearch || 'moderate',\r\n        country: query.country || 'US'\r\n      };\r\n\r\n      const response: AxiosResponse<BraveSearchResponse> = await this.client.get('', { params });\r\n      \r\n      if (response.status !== 200) {\r\n        throw new Error(`Brave Search API returned status ${response.status}`);\r\n      }\r\n\r\n      const results = response.data.web?.results || [];\r\n      console.log(`­ƒöì Found ${results.length} search results`);\r\n      \r\n      return results;\r\n\r\n    } catch (error: any) {\r\n      console.error('ÔØî Brave Search API error:', error.message);\r\n      \r\n      if (axios.isAxiosError(error)) {\r\n        const braveError: BraveSearchError = {\r\n          code: error.code || 'UNKNOWN_ERROR',\r\n          message: error.message,\r\n          details: error.response?.data\r\n        };\r\n        throw braveError;\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search with automatic retry logic\r\n   */\r\n  async searchWithRetry(query: BraveSearchQuery, maxRetries?: number): Promise<BraveSearchResult[]> {\r\n    const retries = maxRetries || this.config.retryAttempts || 3;\r\n    let lastError: any;\r\n\r\n    for (let attempt = 1; attempt <= retries; attempt++) {\r\n      try {\r\n        return await this.search(query);\r\n      } catch (error) {\r\n        lastError = error;\r\n        console.log(`­ƒöì Search attempt ${attempt}/${retries} failed, retrying...`);\r\n        \r\n        if (attempt < retries) {\r\n          // Exponential backoff\r\n          const delay = Math.pow(2, attempt) * 1000;\r\n          await new Promise(resolve => setTimeout(resolve, delay));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError;\r\n  }\r\n\r\n  /**\r\n   * Quick search - simplified interface for common use cases\r\n   */\r\n  async quickSearch(searchTerm: string, options?: { \r\n    count?: number; \r\n    safesearch?: 'strict' | 'moderate' | 'off';\r\n    country?: string;\r\n  }): Promise<BraveSearchResult[]> {\r\n    const query: BraveSearchQuery = {\r\n      q: searchTerm,\r\n      count: options?.count || 5,\r\n      safesearch: options?.safesearch || 'moderate',\r\n      country: options?.country || 'US'\r\n    };\r\n\r\n    return this.searchWithRetry(query);\r\n  }\r\n\r\n  /**\r\n   * Search for recent results (last week)\r\n   */\r\n  async searchRecent(searchTerm: string, count: number = 5): Promise<BraveSearchResult[]> {\r\n    const query: BraveSearchQuery = {\r\n      q: `${searchTerm} after:${this.getLastWeekDate()}`,\r\n      count,\r\n      safesearch: 'moderate'\r\n    };\r\n\r\n    return this.searchWithRetry(query);\r\n  }\r\n\r\n  /**\r\n   * Test the connection to Brave Search API\r\n   */\r\n  async testConnection(): Promise<boolean> {\r\n    try {\r\n      if (this.mockMode) {\r\n        console.log('­ƒöì BraveSearchClient: Mock connection test passed');\r\n        return true;\r\n      }\r\n\r\n      const testResults = await this.quickSearch('test', { count: 1 });\r\n      console.log('­ƒöì BraveSearchClient: Connection test passed');\r\n      return testResults.length >= 0; // Even 0 results is a successful connection\r\n    } catch (error) {\r\n      console.error('ÔØî BraveSearchClient: Connection test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n  /**\r\n   * Real web search using DuckDuckGo as fallback when Brave API is not available\r\n   * This ensures we always return real, live web search results (never placeholders)\r\n   */\r\n  private async mockSearch(query: BraveSearchQuery): Promise<BraveSearchResult[]> {\r\n    console.log(`­ƒöì Brave API not configured - using DuckDuckGo fallback for: \"${query.q}\"`);\r\n    console.log(`ÔÜá´©Å CRITICAL: Configure BRAVE_API_KEY in .env for production-grade search`);\r\n    \r\n    try {\r\n      // Use a real web search fallback - DuckDuckGo instant answers API\r\n      const fallbackResults = await this.fallbackWebSearch(query.q, query.count || 3);\r\n      return fallbackResults;\r\n    } catch (error) {\r\n      console.error('ÔØî Fallback search also failed:', error);\r\n      \r\n      // Only return educational results if all real search methods fail\r\n      return this.getEducationalResults(query);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fallback web search using DuckDuckGo instant answers\r\n   */\r\n  private async fallbackWebSearch(searchTerm: string, count: number): Promise<BraveSearchResult[]> {\r\n    try {\r\n      // DuckDuckGo instant answers API (free, no API key required)\r\n      const response = await axios.get(`https://api.duckduckgo.com/?q=${encodeURIComponent(searchTerm)}&format=json&no_html=1&skip_disambig=1`);\r\n      \r\n      const results: BraveSearchResult[] = [];\r\n      \r\n      // Convert DuckDuckGo results to our format\r\n      if (response.data.AbstractURL) {\r\n        results.push({\r\n          title: response.data.AbstractText || `Search result for \"${searchTerm}\"`,\r\n          url: response.data.AbstractURL,\r\n          description: response.data.Abstract || response.data.AbstractText || 'No description available',\r\n          age: 'Recent',\r\n          language: 'en',\r\n          family_friendly: true\r\n        });\r\n      }\r\n\r\n      // Add related topics if available\r\n      if (response.data.RelatedTopics && response.data.RelatedTopics.length > 0) {\r\n        for (let i = 0; i < Math.min(count - 1, response.data.RelatedTopics.length); i++) {\r\n          const topic = response.data.RelatedTopics[i];\r\n          if (topic.FirstURL) {\r\n            results.push({\r\n              title: topic.Text || `Related: ${searchTerm}`,\r\n              url: topic.FirstURL,\r\n              description: topic.Text || 'Related search result',\r\n              age: 'Recent',\r\n              language: 'en',\r\n              family_friendly: true\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      console.log(`­ƒöì DuckDuckGo fallback returned ${results.length} real results`);\r\n      return results.slice(0, count);\r\n      \r\n    } catch (error) {\r\n      console.error('ÔØî DuckDuckGo fallback failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Educational results - only used when all real search methods fail\r\n   */\r\n  private getEducationalResults(query: BraveSearchQuery): BraveSearchResult[] {\r\n    console.log(`ÔÜá´©Å FALLBACK TO EDUCATIONAL RESULTS - Configure real search API keys!`);\r\n    \r\n    return [\r\n      {\r\n        title: `Configure BRAVE_API_KEY for \"${query.q}\" searches`,\r\n        url: `https://brave.com/search/api/`,\r\n        description: `To get real web search results for \"${query.q}\", configure BRAVE_API_KEY in your .env file. This educational result is shown because no real search APIs are configured.`,\r\n        age: 'Educational',\r\n        language: 'en',\r\n        family_friendly: true\r\n      },\r\n      {\r\n        title: `Search API Configuration Guide`,\r\n        url: `https://github.com/brave/search-api`,\r\n        description: `Learn how to set up Brave Search API or other web search services to replace these educational placeholders with real search results.`,\r\n        age: 'Educational',\r\n        language: 'en',\r\n        family_friendly: true\r\n      }\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Get date string for last week (for recent search)\r\n   */\r\n  private getLastWeekDate(): string {\r\n    const date = new Date();\r\n    date.setDate(date.getDate() - 7);\r\n    return date.toISOString().split('T')[0];\r\n  }\r\n\r\n  /**\r\n   * Get client configuration (without sensitive data)\r\n   */\r\n  getConfig() {\r\n    return {\r\n      baseUrl: this.config.baseUrl,\r\n      timeout: this.config.timeout,\r\n      retryAttempts: this.config.retryAttempts,\r\n      mockMode: this.mockMode\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\geminiClient.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BatchEmbeddingItem' is defined but never used.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EmbeddingTaskType' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3922,3925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3922,3925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10977,10980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10977,10980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14983,14986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14983,14986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Google Gemini API client for AI-powered text processing\r\n\r\nimport axios, { AxiosInstance, AxiosResponse } from 'axios';\r\nimport { \r\n  GeminiConfig, \r\n  GeminiRequest, \r\n  GeminiResponse, \r\n  GeminiMessage,\r\n  GeminiError,\r\n  ChatOptions,\r\n  ChatResponse,\r\n  EmbeddingOptions,\r\n  EmbeddingResult,\r\n  EmbeddingRequest,\r\n  EmbeddingBatchRequest,\r\n  EmbeddingResponse,\r\n  EmbeddingBatchResponse,\r\n  BatchEmbeddingItem,\r\n  EmbeddingTaskType\r\n} from '../types/gemini';\r\nimport { globalProfiler } from '../performance/profiler';\r\n\r\nexport class GeminiClient {\r\n  private client: AxiosInstance;\r\n  private config: GeminiConfig;\r\n  private mockMode: boolean = false;\r\n\r\n  constructor(config: GeminiConfig) {\r\n    this.config = {\r\n      model: 'gemini-2.5-pro-preview-05-06',\r\n      baseUrl: 'https://generativelanguage.googleapis.com/v1beta',\r\n      timeout: 30000,\r\n      retryAttempts: 3,\r\n      ...config\r\n    };\r\n\r\n    // Enable mock mode if no API key provided or in test environment\r\n    this.mockMode = !config.apiKey || config.apiKey === 'your_google_gemini_api_key_here' || process.env.NODE_ENV === 'test';\r\n\r\n    if (!this.mockMode) {\r\n      this.client = axios.create({\r\n        baseURL: this.config.baseUrl!,\r\n        timeout: this.config.timeout!,\r\n        params: {\r\n          key: this.config.apiKey\r\n        },\r\n        headers: {\r\n          'Content-Type': 'application/json'\r\n        }\r\n      });\r\n    } else {\r\n      console.log('­ƒñû GeminiClient: Running in mock mode');\r\n      // Create a dummy client for mock mode\r\n      this.client = axios.create();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate content using Gemini API\r\n   */\r\n  async generateContent(messages: GeminiMessage[], options?: ChatOptions): Promise<ChatResponse> {\r\n    try {\r\n      if (this.mockMode) {\r\n        return this.mockGenerateContent(messages, options);\r\n      }\r\n\r\n      console.log(`­ƒñû Generating content with ${this.config.model}`);\r\n\r\n      const request: GeminiRequest = {\r\n        contents: messages,\r\n        generationConfig: {\r\n          temperature: options?.temperature || 0.7,\r\n          maxOutputTokens: options?.maxTokens || 1000,\r\n          topK: 40,\r\n          topP: 0.95\r\n        },\r\n        safetySettings: [\r\n          {\r\n            category: 'HARM_CATEGORY_HARASSMENT',\r\n            threshold: 'BLOCK_MEDIUM_AND_ABOVE'\r\n          },\r\n          {\r\n            category: 'HARM_CATEGORY_HATE_SPEECH',\r\n            threshold: 'BLOCK_MEDIUM_AND_ABOVE'\r\n          },\r\n          {\r\n            category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\r\n            threshold: 'BLOCK_MEDIUM_AND_ABOVE'\r\n          },\r\n          {\r\n            category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\r\n            threshold: 'BLOCK_MEDIUM_AND_ABOVE'\r\n          }\r\n        ]\r\n      };\r\n\r\n      const endpoint = `/models/${this.config.model}:generateContent`;\r\n      const response: AxiosResponse<GeminiResponse> = await this.client.post(endpoint, request);\r\n\r\n      if (response.status !== 200) {\r\n        throw new Error(`Gemini API returned status ${response.status}`);\r\n      }\r\n\r\n      const candidate = response.data.candidates?.[0];\r\n      if (!candidate) {\r\n        throw new Error('No response generated from Gemini API');\r\n      }\r\n\r\n      const generatedText = candidate.content.parts[0]?.text || '';\r\n      console.log(`­ƒñû Generated ${generatedText.length} characters`);\r\n\r\n      const result: ChatResponse = {\r\n        response: generatedText,\r\n        finishReason: candidate.finishReason,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n      // Add usage metadata if available\r\n      if (response.data.usageMetadata) {\r\n        result.usage = {\r\n          promptTokens: response.data.usageMetadata.promptTokenCount,\r\n          completionTokens: response.data.usageMetadata.candidatesTokenCount,\r\n          totalTokens: response.data.usageMetadata.totalTokenCount\r\n        };\r\n      }\r\n\r\n      return result;\r\n\r\n    } catch (error: any) {\r\n      console.error('ÔØî Gemini API error:', error.message);\r\n      \r\n      if (axios.isAxiosError(error)) {\r\n        // Handle rate limiting by falling back to mock mode\r\n        if (error.response?.status === 429) {\r\n          console.log('ÔÅ│ Rate limit exceeded, using mock response');\r\n          return this.mockGenerateContent(messages, options);\r\n        }\r\n        \r\n        const geminiError: GeminiError = {\r\n          code: error.response?.status || 500,\r\n          message: error.message,\r\n          status: error.response?.statusText || 'Unknown Error',\r\n          details: error.response?.data\r\n        };\r\n        \r\n        throw geminiError;\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple chat interface\r\n   */\r\n  async chat(userPrompt: string, options?: ChatOptions): Promise<ChatResponse> {\r\n    const messages: GeminiMessage[] = [];\r\n\r\n    // Add system prompt if provided\r\n    if (options?.systemPrompt) {\r\n      messages.push({\r\n        role: 'user',\r\n        parts: [{ text: `System: ${options.systemPrompt}` }]\r\n      });\r\n      messages.push({\r\n        role: 'model',\r\n        parts: [{ text: 'I understand. I will follow these instructions.' }]\r\n      });\r\n    }\r\n\r\n    // Add context if provided\r\n    if (options?.context) {\r\n      messages.push({\r\n        role: 'user',\r\n        parts: [{ text: `Context: ${options.context}` }]\r\n      });\r\n    }\r\n\r\n    // Add user prompt\r\n    messages.push({\r\n      role: 'user',\r\n      parts: [{ text: userPrompt }]\r\n    });\r\n\r\n    return this.generateContent(messages, options);\r\n  }\r\n\r\n  /**\r\n   * Analyze text with specific instructions\r\n   */\r\n  async analyzeText(text: string, instruction: string, options?: ChatOptions): Promise<ChatResponse> {\r\n    const userPrompt = `Please analyze the following text according to these instructions: ${instruction}\\n\\nText to analyze:\\n${text}`;\r\n    return this.chat(userPrompt, options);\r\n  }\r\n\r\n  /**\r\n   * Summarize text\r\n   */\r\n  async summarizeText(text: string, maxLength?: number): Promise<ChatResponse> {\r\n    const lengthInstruction = maxLength ? ` in approximately ${maxLength} words` : '';\r\n    const userPrompt = `Please provide a clear and concise summary of the following text${lengthInstruction}:\\n\\n${text}`;\r\n    \r\n    return this.chat(userPrompt, {\r\n      temperature: 0.3,\r\n      maxTokens: maxLength ? Math.ceil(maxLength * 1.5) : 500\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Test the connection to Gemini API\r\n   */\r\n  async testConnection(): Promise<boolean> {\r\n    try {\r\n      if (this.mockMode) {\r\n        console.log('­ƒñû GeminiClient: Mock connection test passed');\r\n        return true;\r\n      }\r\n\r\n      const testResponse = await this.chat('Hello, please respond with \"Test successful\"', {\r\n        temperature: 0.1,\r\n        maxTokens: 50\r\n      });\r\n      \r\n      console.log('­ƒñû GeminiClient: Connection test passed');\r\n      return testResponse.response.length > 0;\r\n    } catch (error) {\r\n      console.error('ÔØî GeminiClient: Connection test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mock content generation for development/testing\r\n   */\r\n  private mockGenerateContent(messages: GeminiMessage[], _options?: ChatOptions): ChatResponse {\r\n    const lastUserMessage = messages.filter(m => m.role === 'user').pop();\r\n    const userText = lastUserMessage?.parts[0]?.text || '';\r\n    \r\n    console.log(`­ƒñû Mock generation for input: \"${userText.substring(0, 50)}...\"`);\r\n      // Generate a fallback response when API is rate limited\r\n    let fallbackResponse: string;\r\n    \r\n    if (userText.toLowerCase().includes('summarize') || userText.toLowerCase().includes('summary')) {\r\n      fallbackResponse = `I understand you'd like a summary. Due to API rate limits, I'm currently operating in limited mode. Please try again in a few moments for full AI analysis capabilities.`;\r\n    } else if (userText.toLowerCase().includes('analyze')) {\r\n      fallbackResponse = `I see you need analysis assistance. Currently experiencing API rate limits - full analytical capabilities will be restored shortly. Please retry your request.`;\r\n    } else if (userText.toLowerCase().includes('hello') || userText.toLowerCase().includes('test')) {\r\n      fallbackResponse = `Hello! I'm OneAgent's AI assistant. Currently operating in limited mode due to API rate limits. Full capabilities will be available once rate limits reset.`;\r\n    } else {\r\n      fallbackResponse = `I understand your request about \"${userText.substring(0, 100)}${userText.length > 100 ? '...' : ''}\". Currently experiencing API rate limits. Please try again shortly for full AI processing capabilities.`;\r\n    }    // Return response immediately (no async needed for fallback)\r\n    return {\r\n      response: fallbackResponse,\r\n      finishReason: 'STOP',\r\n      timestamp: new Date().toISOString()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get client configuration (without sensitive data)\r\n   */\r\n  getConfig() {\r\n    return {\r\n      model: this.config.model,\r\n      baseUrl: this.config.baseUrl,\r\n      timeout: this.config.timeout,\r\n      retryAttempts: this.config.retryAttempts,\r\n      mockMode: this.mockMode\r\n    };\r\n  }\r\n  /**\r\n   * Generate text embedding using Gemini embedding models\r\n   */\r\n  async generateEmbedding(text: string, options?: EmbeddingOptions): Promise<EmbeddingResult> {\r\n    const operationId = `gemini_embedding_${Date.now()}_${Math.random()}`;\r\n    globalProfiler.startOperation(operationId, 'gemini_generate_embedding', { \r\n      textLength: text.length,\r\n      model: options?.model,\r\n      taskType: options?.taskType\r\n    });\r\n\r\n    try {\r\n      if (this.mockMode) {\r\n        const result = this.mockGenerateEmbedding(text, options);\r\n        globalProfiler.endOperation(operationId, true);\r\n        return result;\r\n      }\r\n\r\n      const embeddingModel = options?.model || 'gemini-embedding-exp-03-07';\r\n      console.log(`­ƒöó Generating embedding with ${embeddingModel} for text: \"${text.substring(0, 50)}...\"`);\r\n\r\n      const request: EmbeddingRequest = {\r\n        content: {\r\n          parts: [{ text }]\r\n        }\r\n      };\r\n\r\n      // Add task type if specified\r\n      if (options?.taskType) {\r\n        request.taskType = options.taskType;\r\n      }\r\n\r\n      // Add title if specified\r\n      if (options?.title) {\r\n        request.title = options.title;\r\n      }\r\n\r\n      const endpoint = `/models/${embeddingModel}:embedContent`;\r\n      const response: AxiosResponse<EmbeddingResponse> = await this.client.post(endpoint, request);\r\n\r\n      if (response.status !== 200) {\r\n        throw new Error(`Gemini Embedding API returned status ${response.status}`);\r\n      }      const embedding = response.data.embedding.values;\r\n      console.log(`­ƒöó Generated embedding with ${embedding.length} dimensions`);\r\n\r\n      const result = {\r\n        embedding,\r\n        text,\r\n        taskType: options?.taskType,\r\n        dimensions: embedding.length,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n      globalProfiler.endOperation(operationId, true);\r\n      return result;\r\n\r\n    } catch (error: any) {\r\n      console.error('ÔØî Gemini Embedding API error:', error.message);\r\n      \r\n      if (axios.isAxiosError(error)) {\r\n        // Handle rate limiting by falling back to mock mode\r\n        if (error.response?.status === 429) {\r\n          console.log('ÔÅ│ Rate limit exceeded, using mock embedding');\r\n          const result = this.mockGenerateEmbedding(text, options);\r\n          globalProfiler.endOperation(operationId, true);\r\n          return result;\r\n        }\r\n        \r\n        const geminiError: GeminiError = {\r\n          code: error.response?.status || 500,\r\n          message: error.message,\r\n          status: error.response?.statusText || 'Unknown Error',\r\n          details: error.response?.data\r\n        };\r\n        \r\n        globalProfiler.endOperation(operationId, false, geminiError.message);\r\n        throw geminiError;\r\n      }\r\n      \r\n      globalProfiler.endOperation(operationId, false, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n  /**\r\n   * Generate embeddings for multiple texts in batch\r\n   */\r\n  async generateEmbeddingBatch(texts: string[], options?: EmbeddingOptions): Promise<EmbeddingResult[]> {\r\n    const operationId = `gemini_batch_embedding_${Date.now()}_${Math.random()}`;\r\n    globalProfiler.startOperation(operationId, 'gemini_batch_embeddings', { \r\n      batchSize: texts.length,\r\n      model: options?.model,\r\n      taskType: options?.taskType\r\n    });\r\n\r\n    try {\r\n      if (this.mockMode) {\r\n        const results = await Promise.all(texts.map(text => this.mockGenerateEmbedding(text, options)));\r\n        globalProfiler.endOperation(operationId, true);\r\n        return results;\r\n      }\r\n\r\n      const embeddingModel = options?.model || 'gemini-embedding-exp-03-07';\r\n      console.log(`­ƒöó Generating batch embeddings with ${embeddingModel} for ${texts.length} texts`);      const requests: EmbeddingRequest[] = texts.map(text => {\r\n        const request: EmbeddingRequest = {\r\n          model: `models/${embeddingModel}`,\r\n          content: {\r\n            parts: [{ text }]\r\n          }\r\n        };\r\n\r\n        if (options?.taskType) {\r\n          request.taskType = options.taskType;\r\n        }\r\n\r\n        if (options?.title) {\r\n          request.title = options.title;\r\n        }\r\n\r\n        return request;\r\n      });      const batchRequest: EmbeddingBatchRequest = { requests };      const endpoint = `/models/${embeddingModel}:batchEmbedContents`;  // Correct batch endpoint format\r\n      const response: AxiosResponse<EmbeddingBatchResponse> = await this.client.post(endpoint, batchRequest);\r\n\r\n      if (response.status !== 200) {\r\n        throw new Error(`Gemini Embedding API returned status ${response.status}`);\r\n      }      // Debug: Log the actual response structure\r\n      console.log('­ƒöì Batch embeddings response structure:', JSON.stringify(response.data, null, 2));\r\n\r\n      // Check if response has the expected structure\r\n      if (!response.data.embeddings || !Array.isArray(response.data.embeddings)) {\r\n        throw new Error(`Unexpected batch embeddings response structure: ${JSON.stringify(response.data)}`);\r\n      }      const results: EmbeddingResult[] = response.data.embeddings.map((embeddingResponse, index) => {\r\n        // API returns structure: { \"values\": [...] }\r\n        if (!embeddingResponse.values || !Array.isArray(embeddingResponse.values)) {\r\n          console.error(`Invalid embedding structure at index ${index}:`, embeddingResponse);\r\n          throw new Error(`Cannot find embedding values at index ${index}`);\r\n        }\r\n\r\n        return {\r\n          embedding: embeddingResponse.values,\r\n          text: texts[index],\r\n          taskType: options?.taskType,\r\n          dimensions: embeddingResponse.values.length,\r\n          timestamp: new Date().toISOString()\r\n        };\r\n      });      console.log(`­ƒöó Generated ${results.length} embeddings with ${results[0]?.dimensions || 0} dimensions each`);\r\n      globalProfiler.endOperation(operationId, true);\r\n      return results;\r\n\r\n    } catch (error: any) {\r\n      console.error('ÔØî Gemini Batch Embedding API error:', error.message);\r\n      \r\n      if (axios.isAxiosError(error)) {\r\n        // Handle rate limiting by falling back to mock mode\r\n        if (error.response?.status === 429) {\r\n          console.log('ÔÅ│ Rate limit exceeded, using mock embeddings');\r\n          const results = await Promise.all(texts.map(text => this.mockGenerateEmbedding(text, options)));\r\n          globalProfiler.endOperation(operationId, true);\r\n          return results;\r\n        }\r\n        \r\n        const geminiError: GeminiError = {\r\n          code: error.response?.status || 500,\r\n          message: error.message,\r\n          status: error.response?.statusText || 'Unknown Error',\r\n          details: error.response?.data\r\n        };\r\n        \r\n        globalProfiler.endOperation(operationId, false, geminiError.message);\r\n        throw geminiError;\r\n      }\r\n      \r\n      globalProfiler.endOperation(operationId, false, error.message);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate cosine similarity between two embeddings\r\n   */\r\n  static calculateCosineSimilarity(embedding1: number[], embedding2: number[]): number {\r\n    if (embedding1.length !== embedding2.length) {\r\n      throw new Error('Embeddings must have the same dimensions');\r\n    }\r\n\r\n    let dotProduct = 0;\r\n    let norm1 = 0;\r\n    let norm2 = 0;\r\n\r\n    for (let i = 0; i < embedding1.length; i++) {\r\n      dotProduct += embedding1[i] * embedding2[i];\r\n      norm1 += embedding1[i] * embedding1[i];\r\n      norm2 += embedding2[i] * embedding2[i];\r\n    }\r\n\r\n    const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\r\n    return magnitude === 0 ? 0 : dotProduct / magnitude;\r\n  }\r\n\r\n  /**\r\n   * Find most similar texts using embeddings\r\n   */\r\n  async findSimilarTexts(\r\n    queryText: string, \r\n    candidateTexts: string[], \r\n    options?: EmbeddingOptions & { topK?: number }\r\n  ): Promise<Array<{ text: string; similarity: number; index: number }>> {\r\n    console.log(`­ƒöì Finding similar texts for query: \"${queryText.substring(0, 50)}...\"`);\r\n\r\n    // Generate embedding for query\r\n    const queryEmbedding = await this.generateEmbedding(queryText, {\r\n      ...options,\r\n      taskType: 'RETRIEVAL_QUERY'\r\n    });\r\n\r\n    // Generate embeddings for candidates\r\n    const candidateEmbeddings = await this.generateEmbeddingBatch(candidateTexts, {\r\n      ...options,\r\n      taskType: 'RETRIEVAL_DOCUMENT'\r\n    });\r\n\r\n    // Calculate similarities\r\n    const similarities = candidateEmbeddings.map((candidate, index) => ({\r\n      text: candidate.text,\r\n      similarity: GeminiClient.calculateCosineSimilarity(queryEmbedding.embedding, candidate.embedding),\r\n      index\r\n    }));\r\n\r\n    // Sort by similarity (highest first)\r\n    similarities.sort((a, b) => b.similarity - a.similarity);\r\n\r\n    // Return top K results\r\n    const topK = options?.topK || similarities.length;\r\n    const results = similarities.slice(0, topK);\r\n\r\n    console.log(`­ƒöì Found ${results.length} similar texts, top similarity: ${results[0]?.similarity.toFixed(4) || 0}`);\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Mock embedding generation for development/testing\r\n   */\r\n  private mockGenerateEmbedding(text: string, options?: EmbeddingOptions): EmbeddingResult {\r\n    console.log(`­ƒöó Mock embedding generation for: \"${text.substring(0, 50)}...\"`);\r\n    \r\n    // Generate a realistic mock embedding (384 dimensions like text-embedding-004)\r\n    const dimensions = 384;\r\n    const embedding = Array.from({ length: dimensions }, () => Math.random() * 2 - 1);\r\n    \r\n    // Normalize the embedding to unit length (common practice)\r\n    const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\r\n    const normalizedEmbedding = embedding.map(val => val / magnitude);\r\n\r\n    return {\r\n      embedding: normalizedEmbedding,\r\n      text,\r\n      taskType: options?.taskType,\r\n      dimensions,\r\n      timestamp: new Date().toISOString()\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\geminiEmbeddings.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EmbeddingOptions' is defined but never used.","line":11,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1149,1152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1149,1152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3229,3232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3229,3232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5042,5045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5042,5045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5336,5339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5336,5339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":194,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":194,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6788,6791],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6788,6791],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Gemini Embeddings Tool for OneAgent\r\n * \r\n * Provides semantic search, similarity matching, and embedding-based\r\n * memory enhancement for the OneAgent system using Google Gemini embeddings.\r\n * Updated to use UnifiedMemoryClient.\r\n */\r\n\r\nimport { GeminiClient } from './geminiClient';\r\nimport { OneAgentMemory, OneAgentMemoryConfig } from '../memory/OneAgentMemory';\r\nimport { EmbeddingOptions, EmbeddingResult, EmbeddingTaskType } from '../types/gemini';\r\nimport { globalProfiler } from '../performance/profiler';\r\n\r\nexport interface SemanticSearchOptions {\r\n  taskType?: EmbeddingTaskType;\r\n  topK?: number;\r\n  similarityThreshold?: number;\r\n  model?: 'text-embedding-004' | 'embedding-001' | 'gemini-embedding-exp-03-07';\r\n}\r\n\r\nexport interface MemoryEmbeddingOptions extends SemanticSearchOptions {\r\n  workflowId?: string;\r\n  sessionId?: string;\r\n  memoryType?: 'short_term' | 'long_term' | 'workflow' | 'session';\r\n}\r\n\r\nexport interface SemanticSearchResult {\r\n  memory: {\r\n    id: string;\r\n    type: string;\r\n    content: string;\r\n    agentId: string;\r\n    relevanceScore: number;\r\n    timestamp: Date;\r\n    metadata?: Record<string, any>;\r\n    summary?: string;\r\n  };\r\n  similarity: number;\r\n  embeddingResult?: EmbeddingResult;\r\n}\r\n\r\nexport interface EmbeddingAnalytics {\r\n  totalMemories: number;\r\n  searchResults: number;\r\n  averageSimilarity: number;\r\n  topSimilarity: number;\r\n  processingTime: number;\r\n}\r\n\r\n/**\r\n * Gemini Embeddings Tool\r\n * Integrates Gemini embeddings with UnifiedMemoryClient for semantic operations\r\n */\r\nexport class GeminiEmbeddingsTool {\r\n  private geminiClient: GeminiClient;\r\n  private memorySystem: OneAgentMemory;\r\n  private embeddingCache: Map<string, EmbeddingResult> = new Map();\r\n\r\n  constructor(geminiClient: GeminiClient, memorySystem?: OneAgentMemory) {\r\n    this.geminiClient = geminiClient;\r\n    if (memorySystem) {\r\n      this.memorySystem = memorySystem;\r\n    } else {\r\n      const memoryConfig: OneAgentMemoryConfig = {\r\n        apiKey: process.env.MEM0_API_KEY || 'demo-key',\r\n        apiUrl: process.env.MEM0_API_URL\r\n      };\r\n      this.memorySystem = new OneAgentMemory(memoryConfig);\r\n    }\r\n    console.log('­ƒöó GeminiEmbeddingsTool initialized with canonical OneAgentMemory');\r\n  }\r\n\r\n  /**\r\n   * Perform semantic search across memories using canonical memory system\r\n   */\r\n  async semanticSearch(\r\n    query: string,\r\n    options?: MemoryEmbeddingOptions\r\n  ): Promise<{ results: SemanticSearchResult[]; analytics: EmbeddingAnalytics }> {\r\n    const startTime = Date.now();\r\n    const operationId = `semantic-search-${Date.now()}`;\r\n    try {\r\n      globalProfiler.startOperation(operationId, 'semantic-search');\r\n      // If mem0 supports embedding-based search, delegate to it:\r\n      const searchResults = await this.memorySystem.searchMemory({\r\n        type: 'conversations',\r\n        query,\r\n        topK: options?.topK || 10,\r\n        similarityThreshold: options?.similarityThreshold || 0.1,\r\n        embeddingModel: options?.model || 'gemini-embedding-exp-03-07',\r\n        semanticSearch: true\r\n      });\r\n      // Map results to SemanticSearchResult format\r\n      const results: SemanticSearchResult[] = (searchResults?.results || []).map((memory: any) => ({\r\n        memory: {\r\n          id: memory.id,\r\n          type: memory.type || 'conversation',\r\n          content: memory.content,\r\n          agentId: memory.agentId || 'default',\r\n          relevanceScore: memory.similarity || memory.relevanceScore || 0,\r\n          timestamp: memory.timestamp ? new Date(memory.timestamp) : new Date(),\r\n          metadata: memory.metadata || {},\r\n          summary: memory.summary || undefined\r\n        },\r\n        similarity: memory.similarity || memory.relevanceScore || 0,\r\n        embeddingResult: memory.embeddingResult || undefined\r\n      }));\r\n      const analytics: EmbeddingAnalytics = {\r\n        totalMemories: searchResults?.total || results.length,\r\n        searchResults: results.length,\r\n        averageSimilarity: results.length > 0 ? results.reduce((sum, r) => sum + r.similarity, 0) / results.length : 0,\r\n        topSimilarity: results.length > 0 ? results[0].similarity : 0,\r\n        processingTime: Date.now() - startTime\r\n      };\r\n      globalProfiler.endOperation(operationId, true);\r\n      return { results, analytics };\r\n    } catch (error) {\r\n      globalProfiler.endOperation(operationId, false, error?.toString());\r\n      console.error('ÔØî Semantic search failed:', error);\r\n      return {\r\n        results: [],\r\n        analytics: {\r\n          totalMemories: 0,\r\n          searchResults: 0,\r\n          averageSimilarity: 0,\r\n          topSimilarity: 0,\r\n          processingTime: Date.now() - startTime\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Store memory with embedding if required (otherwise use canonical addMemory)\r\n   */\r\n  async storeMemoryWithEmbedding(\r\n    content: string,\r\n    agentId: string,\r\n    userId: string,\r\n    memoryType: 'conversation' | 'learning' | 'pattern' = 'conversation',\r\n    metadata?: Record<string, any>\r\n  ): Promise<{ memoryId: string; embedding?: EmbeddingResult }> {\r\n    const operationId = `store-memory-${Date.now()}`;\r\n    try {\r\n      globalProfiler.startOperation(operationId, 'store-memory-embedding');\r\n      // If mem0 supports embedding, just add memory\r\n      const memoryData: any = {\r\n        id: `${memoryType}_${Date.now()}`,\r\n        agentId,\r\n        userId,\r\n        content,\r\n        timestamp: new Date(),\r\n        metadata: {\r\n          type: memoryType,\r\n          agentId,\r\n          ...(metadata || {})\r\n        }\r\n      };\r\n      await this.memorySystem.addMemory({\r\n        ...memoryData\r\n      });\r\n      globalProfiler.endOperation(operationId, true);\r\n      return { memoryId: memoryData.id };\r\n    } catch (error) {\r\n      globalProfiler.endOperation(operationId, false, error?.toString());\r\n      console.error('ÔØî Memory storage with embedding failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate cosine similarity between two embeddings (utility, not used if mem0 handles search)\r\n   */\r\n  private calculateCosineSimilarity(embedding1: number[], embedding2: number[]): number {\r\n    if (embedding1.length !== embedding2.length) {\r\n      throw new Error('Embeddings must have the same length');\r\n    }\r\n    let dotProduct = 0;\r\n    let norm1 = 0;\r\n    let norm2 = 0;\r\n    for (let i = 0; i < embedding1.length; i++) {\r\n      dotProduct += embedding1[i] * embedding2[i];\r\n      norm1 += embedding1[i] * embedding1[i];\r\n      norm2 += embedding2[i] * embedding2[i];\r\n    }\r\n    return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));\r\n  }\r\n\r\n  /**\r\n   * Find similar memories (delegates to semanticSearch)\r\n   */\r\n  async findSimilarMemories(\r\n    queryText: string,\r\n    _searchQuery?: any,\r\n    options?: MemoryEmbeddingOptions\r\n  ): Promise<{\r\n    results: SemanticSearchResult[];\r\n    analytics: EmbeddingAnalytics;\r\n  }> {\r\n    return this.semanticSearch(queryText, options);\r\n  }\r\n\r\n  /**\r\n   * Clear embedding cache (utility)\r\n   */\r\n  clearCache(): void {\r\n    this.embeddingCache.clear();\r\n    console.log('­ƒº╣ Embedding cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics (utility)\r\n   */\r\n  getCacheStats(): { size: number; keys: string[] } {\r\n    return {\r\n      size: this.embeddingCache.size,\r\n      keys: Array.from(this.embeddingCache.keys())\r\n    };\r\n  }\r\n}\r\n// All memory and embedding operations are now handled by the canonical OneAgentMemory (mem0) system.\r\n// This tool only provides custom embedding logic if required by future workflows.\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\webFetch.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ContentExtractionResult' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4761,4764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4761,4764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":354,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":354,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":564,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":564,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18890,18893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18890,18893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":577,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":577,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19260,19263],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19260,19263],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// filepath: coreagent/tools/webFetch.ts\r\n// Web content fetching and extraction tool\r\n\r\nimport axios, { AxiosInstance, AxiosResponse } from 'axios';\r\nimport { JSDOM } from 'jsdom';\r\nimport { \r\n  WebFetchOptions, \r\n  WebFetchResponse, \r\n  WebFetchContent, \r\n  WebFetchMetadata,\r\n  WebFetchConfig,\r\n  WebFetchError,\r\n  ContentExtractionResult\r\n} from '../types/webFetch';\r\n\r\nexport class WebFetchTool {\r\n  private client: AxiosInstance;\r\n  private config: WebFetchConfig;\r\n  private mockMode: boolean = false;\r\n  private lastRequestTime: number = 0;\r\n  private requestCount: number = 0;\r\n\r\n  constructor(config?: Partial<WebFetchConfig>) {\r\n    this.config = {\r\n      defaultTimeout: 10000,\r\n      defaultUserAgent: 'OneAgent-WebFetchTool/1.0 (https://github.com/oneagent)',\r\n      maxRetries: 3,\r\n      retryDelay: 1000,\r\n      maxContentSize: 10 * 1024 * 1024, // 10MB\r\n      allowedContentTypes: [\r\n        'text/html',\r\n        'text/plain',\r\n        'text/xml',\r\n        'application/xml',\r\n        'application/json',\r\n        'text/markdown',\r\n        'text/css',\r\n        'application/javascript',\r\n        'text/javascript'\r\n      ],\r\n      rateLimit: {\r\n        requestsPerSecond: 2,\r\n        requestsPerMinute: 60\r\n      },\r\n      ...config\r\n    };    // Enable mock mode in test environment or when specified\r\n    this.mockMode = process.env.NODE_ENV === 'test' || (config?.defaultUserAgent?.includes('mock') ?? false);\r\n\r\n    if (!this.mockMode) {\r\n      this.client = axios.create({\r\n        timeout: this.config.defaultTimeout,\r\n        maxRedirects: 5,\r\n        validateStatus: (status) => status < 500, // Don't throw on client errors (4xx)\r\n        headers: {\r\n          'User-Agent': this.config.defaultUserAgent,\r\n          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,text/plain;q=0.8,*/*;q=0.7',\r\n          'Accept-Language': 'en-US,en;q=0.9',\r\n          'Accept-Encoding': 'gzip, deflate',\r\n          'DNT': '1', // Do Not Track\r\n          'Connection': 'keep-alive',\r\n          'Upgrade-Insecure-Requests': '1'\r\n        }\r\n      });\r\n    } else {\r\n      console.log('­ƒîÉ WebFetchTool: Running in mock mode');\r\n      // Create dummy client for mock mode\r\n      this.client = axios.create();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fetch content from a URL with full content extraction\r\n   */\r\n  async fetchContent(options: WebFetchOptions): Promise<WebFetchResponse> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      if (this.mockMode) {\r\n        return this.mockFetch(options);\r\n      }\r\n\r\n      // Validate URL if requested\r\n      if (options.validateUrl !== false) {\r\n        this.validateUrl(options.url);\r\n      }\r\n\r\n      // Enforce rate limiting\r\n      await this.enforceRateLimit();\r\n\r\n      console.log(`­ƒîÉ WebFetchTool: Fetching content from ${options.url}`);\r\n\r\n      // Configure request options\r\n      const requestConfig = {\r\n        timeout: options.timeout || this.config.defaultTimeout,\r\n        maxRedirects: options.maxRedirects || 5,\r\n        ...(options.userAgent && { \r\n          headers: { 'User-Agent': options.userAgent } \r\n        })\r\n      };\r\n\r\n      const response: AxiosResponse = await this.client.get(options.url, requestConfig);\r\n      \r\n      // Check content size\r\n      const contentLength = response.headers['content-length'];\r\n      if (contentLength && parseInt(contentLength) > this.config.maxContentSize) {\r\n        throw new Error(`Content too large: ${contentLength} bytes (max: ${this.config.maxContentSize})`);\r\n      }\r\n\r\n      // Check content type\r\n      const contentType = response.headers['content-type'] || 'text/plain';\r\n      if (!this.isAllowedContentType(contentType)) {\r\n        console.warn(`ÔÜá´©Å Content type ${contentType} not in allowed list, proceeding anyway`);\r\n      }\r\n\r\n      // Extract content\r\n      const content = await this.extractContent(response.data, contentType, options);\r\n      \r\n      // Extract metadata (only for HTML content)\r\n      const metadata = contentType.includes('text/html') && options.extractMetadata !== false\r\n        ? await this.extractMetadata(response.data, options.url, response.request?.responseURL)\r\n        : {};\r\n\r\n      const fetchTime = Date.now() - startTime;\r\n\r\n      const result: WebFetchResponse = {\r\n        url: options.url,\r\n        finalUrl: response.request?.responseURL || options.url,\r\n        statusCode: response.status,\r\n        statusText: response.statusText,\r\n        headers: this.normalizeHeaders(response.headers),\r\n        content,\r\n        metadata,\r\n        fetchTime,\r\n        timestamp: new Date().toISOString(),\r\n        success: true\r\n      };\r\n\r\n      console.log(`Ô£à WebFetchTool: Successfully fetched ${content.size} bytes in ${fetchTime}ms`);\r\n      return result;\r\n\r\n    } catch (error: any) {\r\n      const fetchTime = Date.now() - startTime;\r\n      console.error('ÔØî WebFetchTool error:', error.message);\r\n      \r\n      const webFetchError: WebFetchError = {\r\n        code: error.code || 'FETCH_ERROR',\r\n        message: error.message,\r\n        url: options.url,\r\n        statusCode: error.response?.status,\r\n        details: error.response?.data\r\n      };\r\n\r\n      return {\r\n        url: options.url,\r\n        statusCode: error.response?.status || 0,\r\n        statusText: error.response?.statusText || 'Error',\r\n        headers: error.response ? this.normalizeHeaders(error.response.headers) : {},\r\n        content: {\r\n          raw: '',\r\n          text: '',\r\n          contentType: 'text/plain',\r\n          encoding: 'utf-8',\r\n          size: 0\r\n        },\r\n        metadata: {},\r\n        fetchTime,\r\n        timestamp: new Date().toISOString(),\r\n        success: false,\r\n        error: webFetchError.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Quick fetch - simplified interface for common use cases\r\n   */\r\n  async quickFetch(url: string, extractContent: boolean = true): Promise<WebFetchResponse> {\r\n    return this.fetchContent({\r\n      url,\r\n      extractContent,\r\n      extractMetadata: extractContent\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch multiple URLs concurrently (with rate limiting)\r\n   */\r\n  async fetchMultiple(urls: string[], options?: Partial<WebFetchOptions>): Promise<WebFetchResponse[]> {\r\n    console.log(`­ƒîÉ WebFetchTool: Fetching ${urls.length} URLs concurrently`);\r\n    \r\n    const results: WebFetchResponse[] = [];\r\n    \r\n    // Process URLs in batches to respect rate limits\r\n    const batchSize = Math.min(3, urls.length);\r\n    for (let i = 0; i < urls.length; i += batchSize) {\r\n      const batch = urls.slice(i, i + batchSize);\r\n      const batchPromises = batch.map(url => \r\n        this.fetchContent({ url, ...options })\r\n      );\r\n      \r\n      const batchResults = await Promise.allSettled(batchPromises);\r\n      results.push(...batchResults.map(result => \r\n        result.status === 'fulfilled' ? result.value : this.createErrorResponse(\r\n          batch[batchResults.indexOf(result)], \r\n          result.reason\r\n        )\r\n      ));\r\n      \r\n      // Add delay between batches\r\n      if (i + batchSize < urls.length) {\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Test the web fetch functionality\r\n   */\r\n  async testFetch(): Promise<boolean> {\r\n    try {\r\n      console.log('­ƒîÉ Testing web fetch functionality...');\r\n      \r\n      const testResult = await this.quickFetch('https://httpbin.org/user-agent');\r\n      const isWorking = testResult.success && testResult.content.size > 0;\r\n      \r\n      if (isWorking) {\r\n        console.log('Ô£à Web fetch test passed');\r\n      } else {\r\n        console.log('ÔÜá´©Å Web fetch test failed or returned no content');\r\n      }\r\n      \r\n      return isWorking;\r\n    } catch (error) {\r\n      console.error('ÔØî Web fetch test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // PRIVATE HELPER METHODS\r\n\r\n  /**\r\n   * Validate URL format and security\r\n   */\r\n  private validateUrl(url: string): void {\r\n    try {\r\n      const urlObj = new URL(url);\r\n      \r\n      // Check protocol\r\n      if (!['http:', 'https:'].includes(urlObj.protocol)) {\r\n        throw new Error(`Unsupported protocol: ${urlObj.protocol}`);\r\n      }\r\n      \r\n      // Check for blocked domains\r\n      if (this.config.blockedDomains?.some(domain => \r\n        urlObj.hostname.includes(domain)\r\n      )) {\r\n        throw new Error(`Domain ${urlObj.hostname} is blocked`);\r\n      }\r\n      \r\n      // Prevent localhost access in production (security measure)\r\n      if (process.env.NODE_ENV === 'production' && \r\n          ['localhost', '127.0.0.1', '::1'].includes(urlObj.hostname)) {\r\n        throw new Error('Localhost access not allowed in production');\r\n      }\r\n      \r\n    } catch (error) {\r\n      if (error instanceof TypeError) {\r\n        throw new Error(`Invalid URL format: ${url}`);\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enforce rate limiting\r\n   */\r\n  private async enforceRateLimit(): Promise<void> {\r\n    const now = Date.now();\r\n    const timeSinceLastRequest = now - this.lastRequestTime;\r\n    const minInterval = 1000 / (this.config.rateLimit?.requestsPerSecond || 2);\r\n    \r\n    if (timeSinceLastRequest < minInterval) {\r\n      const delay = minInterval - timeSinceLastRequest;\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n    \r\n    this.lastRequestTime = Date.now();\r\n    this.requestCount++;\r\n  }\r\n\r\n  /**\r\n   * Check if content type is allowed\r\n   */\r\n  private isAllowedContentType(contentType: string): boolean {\r\n    return this.config.allowedContentTypes.some(allowed => \r\n      contentType.toLowerCase().includes(allowed.toLowerCase())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Extract and clean content based on content type\r\n   */\r\n  private async extractContent(\r\n    rawContent: string, \r\n    contentType: string, \r\n    options: WebFetchOptions\r\n  ): Promise<WebFetchContent> {\r\n    if (options.extractContent === false) {\r\n      return {\r\n        raw: rawContent,\r\n        text: rawContent,\r\n        contentType,\r\n        encoding: 'utf-8',\r\n        size: Buffer.byteLength(rawContent, 'utf8')\r\n      };\r\n    }\r\n\r\n    let cleanText = rawContent;\r\n    let cleanHtml: string | undefined;\r\n    let wordCount: number | undefined;\r\n\r\n    // HTML content extraction\r\n    if (contentType.includes('text/html')) {\r\n      try {\r\n        const dom = new JSDOM(rawContent);\r\n        const document = dom.window.document;\r\n        \r\n        // Remove script and style elements\r\n        const scriptsAndStyles = document.querySelectorAll('script, style, noscript');\r\n        scriptsAndStyles.forEach(element => element.remove());\r\n        \r\n        // Extract clean text\r\n        cleanText = document.body?.textContent || document.textContent || '';\r\n        cleanText = cleanText.replace(/\\s+/g, ' ').trim();\r\n        \r\n        // Keep cleaned HTML\r\n        cleanHtml = document.body?.innerHTML || document.documentElement.innerHTML;\r\n        \r\n        wordCount = cleanText.split(/\\s+/).filter(word => word.length > 0).length;\r\n        \r\n      } catch (error) {\r\n        console.warn('ÔÜá´©Å HTML parsing failed, using raw content:', error);\r\n        cleanText = rawContent.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\r\n      }\r\n    }\r\n    \r\n    // JSON content\r\n    else if (contentType.includes('application/json')) {\r\n      try {\r\n        const jsonData = JSON.parse(rawContent);\r\n        cleanText = JSON.stringify(jsonData, null, 2);\r\n      } catch (error) {\r\n        console.warn('ÔÜá´©Å JSON parsing failed, using raw content');\r\n      }\r\n    }\r\n    \r\n    // XML content  \r\n    else if (contentType.includes('xml')) {\r\n      // Basic XML cleaning - remove tags for text extraction\r\n      cleanText = rawContent.replace(/<[^>]*>/g, ' ').replace(/\\s+/g, ' ').trim();\r\n    }    return {\r\n      raw: rawContent,\r\n      text: cleanText,\r\n      ...(cleanHtml && { html: cleanHtml }),\r\n      contentType,\r\n      encoding: 'utf-8', // Assume UTF-8 for now\r\n      size: Buffer.byteLength(rawContent, 'utf8'),\r\n      ...(wordCount && { wordCount })\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Extract metadata from HTML content\r\n   */\r\n  private async extractMetadata(\r\n    htmlContent: string, \r\n    originalUrl: string, \r\n    finalUrl?: string\r\n  ): Promise<WebFetchMetadata> {\r\n    try {\r\n      const dom = new JSDOM(htmlContent);\r\n      const document = dom.window.document;\r\n        const metadata: WebFetchMetadata = {};\r\n      \r\n      // Basic metadata - only assign if value exists\r\n      const title = document.querySelector('title')?.textContent?.trim();\r\n      if (title) metadata.title = title;\r\n      \r\n      const description = this.getMetaContent(document, 'description');\r\n      if (description) metadata.description = description;\r\n      \r\n      const keywordsRaw = this.getMetaContent(document, 'keywords');\r\n      if (keywordsRaw) metadata.keywords = keywordsRaw.split(',').map(k => k.trim());\r\n      \r\n      const author = this.getMetaContent(document, 'author');\r\n      if (author) metadata.author = author;\r\n      \r\n      const language = document.documentElement.lang || this.getMetaContent(document, 'language');\r\n      if (language) metadata.language = language;\r\n      \r\n      const canonical = document.querySelector('link[rel=\"canonical\"]')?.getAttribute('href');\r\n      if (canonical) metadata.canonical = canonical;\r\n      \r\n      const robots = this.getMetaContent(document, 'robots');\r\n      if (robots) metadata.robots = robots;\r\n      \r\n      const viewport = this.getMetaContent(document, 'viewport');\r\n      if (viewport) metadata.viewport = viewport;\r\n      \r\n      // Open Graph metadata\r\n      const ogTitle = this.getMetaProperty(document, 'og:title');\r\n      if (ogTitle) metadata.ogTitle = ogTitle;\r\n      \r\n      const ogDescription = this.getMetaProperty(document, 'og:description');\r\n      if (ogDescription) metadata.ogDescription = ogDescription;\r\n      \r\n      const ogImage = this.getMetaProperty(document, 'og:image');\r\n      if (ogImage) metadata.ogImage = ogImage;\r\n      \r\n      const ogUrl = this.getMetaProperty(document, 'og:url');\r\n      if (ogUrl) metadata.ogUrl = ogUrl;\r\n      \r\n      const ogType = this.getMetaProperty(document, 'og:type');\r\n      if (ogType) metadata.ogType = ogType;\r\n      \r\n      const ogSiteName = this.getMetaProperty(document, 'og:site_name');\r\n      if (ogSiteName) metadata.ogSiteName = ogSiteName;\r\n      \r\n      // Twitter Card metadata\r\n      const twitterCard = this.getMetaName(document, 'twitter:card');\r\n      if (twitterCard) metadata.twitterCard = twitterCard;\r\n      \r\n      const twitterTitle = this.getMetaName(document, 'twitter:title');\r\n      if (twitterTitle) metadata.twitterTitle = twitterTitle;\r\n      \r\n      const twitterDescription = this.getMetaName(document, 'twitter:description');\r\n      if (twitterDescription) metadata.twitterDescription = twitterDescription;\r\n      \r\n      const twitterImage = this.getMetaName(document, 'twitter:image');\r\n      if (twitterImage) metadata.twitterImage = twitterImage;\r\n      \r\n      const twitterSite = this.getMetaName(document, 'twitter:site');\r\n      if (twitterSite) metadata.twitterSite = twitterSite;\r\n      \r\n      // Additional metadata\r\n      const favicon = this.extractFavicon(document, finalUrl || originalUrl);\r\n      if (favicon) metadata.favicon = favicon;\r\n      \r\n      const generator = this.getMetaContent(document, 'generator');\r\n      if (generator) metadata.generator = generator;\r\n      \r\n      const lastModified = this.getMetaContent(document, 'last-modified');\r\n      if (lastModified) metadata.lastModified = lastModified;\r\n      \r\n      const publishedTime = this.getMetaProperty(document, 'article:published_time');\r\n      if (publishedTime) metadata.publishedTime = publishedTime;\r\n      \r\n      const modifiedTime = this.getMetaProperty(document, 'article:modified_time');\r\n      if (modifiedTime) metadata.modifiedTime = modifiedTime;\r\n      \r\n      // Extract images and links\r\n      metadata.images = this.extractImages(document, finalUrl || originalUrl);\r\n      metadata.links = this.extractLinks(document, finalUrl || originalUrl);\r\n      \r\n      return metadata;\r\n      \r\n    } catch (error) {\r\n      console.warn('ÔÜá´©Å Metadata extraction failed:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get meta content by name\r\n   */\r\n  private getMetaContent(document: Document, name: string): string | undefined {\r\n    return document.querySelector(`meta[name=\"${name}\"]`)?.getAttribute('content') || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get meta content by property (for Open Graph)\r\n   */\r\n  private getMetaProperty(document: Document, property: string): string | undefined {\r\n    return document.querySelector(`meta[property=\"${property}\"]`)?.getAttribute('content') || undefined;\r\n  }\r\n\r\n  /**\r\n   * Get meta content by name attribute (for Twitter Cards)\r\n   */\r\n  private getMetaName(document: Document, name: string): string | undefined {\r\n    return document.querySelector(`meta[name=\"${name}\"]`)?.getAttribute('content') || undefined;\r\n  }\r\n\r\n  /**\r\n   * Extract favicon URL\r\n   */\r\n  private extractFavicon(document: Document, baseUrl: string): string | undefined {\r\n    const selectors = [\r\n      'link[rel=\"icon\"]',\r\n      'link[rel=\"shortcut icon\"]', \r\n      'link[rel=\"apple-touch-icon\"]'\r\n    ];\r\n    \r\n    for (const selector of selectors) {\r\n      const link = document.querySelector(selector);\r\n      if (link) {\r\n        const href = link.getAttribute('href');\r\n        if (href) {\r\n          return this.resolveUrl(href, baseUrl);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Default favicon location\r\n    try {\r\n      const url = new URL(baseUrl);\r\n      return `${url.protocol}//${url.host}/favicon.ico`;\r\n    } catch {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract image URLs from page\r\n   */\r\n  private extractImages(document: Document, baseUrl: string): string[] {\r\n    const images = Array.from(document.querySelectorAll('img[src]'));\r\n    return images\r\n      .map(img => img.getAttribute('src'))\r\n      .filter((src): src is string => !!src)\r\n      .map(src => this.resolveUrl(src, baseUrl))\r\n      .slice(0, 20); // Limit to first 20 images\r\n  }\r\n\r\n  /**\r\n   * Extract link URLs from page\r\n   */\r\n  private extractLinks(document: Document, baseUrl: string): string[] {\r\n    const links = Array.from(document.querySelectorAll('a[href]'));\r\n    return links\r\n      .map(link => link.getAttribute('href'))\r\n      .filter((href): href is string => !!href)\r\n      .filter(href => href.startsWith('http') || href.startsWith('/'))\r\n      .map(href => this.resolveUrl(href, baseUrl))\r\n      .slice(0, 50); // Limit to first 50 links\r\n  }\r\n\r\n  /**\r\n   * Resolve relative URLs to absolute URLs\r\n   */\r\n  private resolveUrl(url: string, baseUrl: string): string {\r\n    try {\r\n      return new URL(url, baseUrl).href;\r\n    } catch {\r\n      return url;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Normalize response headers\r\n   */\r\n  private normalizeHeaders(headers: any): Record<string, string> {\r\n    const normalized: Record<string, string> = {};\r\n    for (const [key, value] of Object.entries(headers)) {\r\n      if (typeof value === 'string') {\r\n        normalized[key.toLowerCase()] = value;\r\n      }\r\n    }\r\n    return normalized;\r\n  }\r\n\r\n  /**\r\n   * Create error response\r\n   */\r\n  private createErrorResponse(url: string, error: any): WebFetchResponse {\r\n    return {\r\n      url,\r\n      statusCode: 0,\r\n      statusText: 'Error',\r\n      headers: {},\r\n      content: {\r\n        raw: '',\r\n        text: '',\r\n        contentType: 'text/plain',\r\n        encoding: 'utf-8',\r\n        size: 0\r\n      },\r\n      metadata: {},\r\n      fetchTime: 0,\r\n      timestamp: new Date().toISOString(),\r\n      success: false,\r\n      error: error.message || 'Unknown error'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Mock fetch implementation for development/testing\r\n   */\r\n  private mockFetch(options: WebFetchOptions): WebFetchResponse {\r\n    console.log(`­ƒîÉ Mock fetch for: ${options.url}`);\r\n    \r\n    const mockHtml = `\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <meta name=\"description\" content=\"Mock webpage content for OneAgent WebFetchTool testing\">\r\n    <meta property=\"og:title\" content=\"Mock Page Title\">\r\n    <meta property=\"og:description\" content=\"Mock webpage for testing WebFetchTool functionality\">\r\n    <title>Mock Page Title - OneAgent Test</title>\r\n</head>\r\n<body>\r\n    <h1>Mock Page Content</h1>\r\n    <p>This is mock content returned by WebFetchTool for URL: ${options.url}</p>\r\n    <p>In production, this would be real webpage content fetched from the actual URL.</p>\r\n    <a href=\"https://example.com/link1\">Mock Link 1</a>\r\n    <a href=\"https://example.com/link2\">Mock Link 2</a>\r\n    <img src=\"https://example.com/image1.jpg\" alt=\"Mock Image 1\">\r\n</body>\r\n</html>`;\r\n\r\n    const mockContent: WebFetchContent = {\r\n      raw: mockHtml,\r\n      text: 'Mock Page Content This is mock content returned by WebFetchTool for URL: ' + options.url + ' In production, this would be real webpage content fetched from the actual URL.',\r\n      html: '<h1>Mock Page Content</h1><p>This is mock content returned by WebFetchTool for URL: ' + options.url + '</p><p>In production, this would be real webpage content fetched from the actual URL.</p><a href=\"https://example.com/link1\">Mock Link 1</a><a href=\"https://example.com/link2\">Mock Link 2</a><img src=\"https://example.com/image1.jpg\" alt=\"Mock Image 1\">',\r\n      contentType: 'text/html',\r\n      encoding: 'utf-8',\r\n      size: mockHtml.length,\r\n      wordCount: 25\r\n    };\r\n\r\n    const mockMetadata: WebFetchMetadata = {\r\n      title: 'Mock Page Title - OneAgent Test',\r\n      description: 'Mock webpage content for OneAgent WebFetchTool testing',\r\n      language: 'en',\r\n      ogTitle: 'Mock Page Title',\r\n      ogDescription: 'Mock webpage for testing WebFetchTool functionality',\r\n      images: ['https://example.com/image1.jpg'],\r\n      links: ['https://example.com/link1', 'https://example.com/link2']\r\n    };\r\n\r\n    return {\r\n      url: options.url,\r\n      finalUrl: options.url,\r\n      statusCode: 200,\r\n      statusText: 'OK',\r\n      headers: {\r\n        'content-type': 'text/html; charset=utf-8',\r\n        'content-length': mockHtml.length.toString()\r\n      },\r\n      content: mockContent,\r\n      metadata: mockMetadata,\r\n      fetchTime: 150, // Mock 150ms fetch time\r\n      timestamp: new Date().toISOString(),\r\n      success: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get tool configuration\r\n   */\r\n  getConfig() {\r\n    return {\r\n      provider: 'WebFetch',\r\n      mockMode: this.mockMode,\r\n      config: {\r\n        ...this.config,\r\n        // Don't expose sensitive data\r\n        defaultUserAgent: this.config.defaultUserAgent\r\n      }\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arne\\.cline\\mcps\\OneAgent\\coreagent\\tools\\webSearch.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2730,2733],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2730,2733],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// filepath: coreagent/tools/webSearch.ts\r\n// Web search tool using Brave Search API\r\n\r\nimport { BraveSearchClient } from './braveSearchClient';\r\nimport { BraveSearchResult } from '../types/braveSearch';\r\n\r\nexport interface WebSearchOptions {\r\n  query: string;\r\n  count?: number;\r\n  safesearch?: 'strict' | 'moderate' | 'off';\r\n  country?: string;\r\n  includeRecent?: boolean; // Also search for recent results\r\n}\r\n\r\nexport interface WebSearchResponse {\r\n  query: string;\r\n  totalResults: number;\r\n  results: Array<{\r\n    title: string;\r\n    url: string;\r\n    description: string;\r\n    age?: string;\r\n    relevanceScore?: number;\r\n  }>;\r\n  searchTime: number; // milliseconds\r\n  timestamp: string;\r\n}\r\n\r\nexport class WebSearchTool {\r\n  private braveClient: BraveSearchClient;\r\n\r\n  constructor(braveClient: BraveSearchClient) {\r\n    this.braveClient = braveClient;\r\n  }\r\n\r\n  /**\r\n   * Perform a web search and return formatted results\r\n   */\r\n  async search(options: WebSearchOptions): Promise<WebSearchResponse> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      console.log(`­ƒöì WebSearchTool: Searching for \"${options.query}\"`);\r\n\r\n      const searchOptions = {\r\n        count: options.count || 5,\r\n        safesearch: options.safesearch || 'moderate',\r\n        country: options.country || 'US'\r\n      };\r\n\r\n      // Perform main search\r\n      const results = await this.braveClient.quickSearch(options.query, searchOptions);\r\n      \r\n      // Optionally include recent results\r\n      let recentResults: BraveSearchResult[] = [];\r\n      if (options.includeRecent) {\r\n        try {\r\n          recentResults = await this.braveClient.searchRecent(options.query, 2);\r\n        } catch (error) {\r\n          console.log('ÔÜá´©Å Could not fetch recent results:', error);\r\n        }\r\n      }\r\n\r\n      // Combine and deduplicate results\r\n      const allResults = this.combineAndDeduplicateResults(results, recentResults);\r\n        // Format results\r\n      const formattedResults = allResults.slice(0, options.count || 5).map((result, index) => ({\r\n        title: result.title,\r\n        url: result.url,\r\n        description: result.description,\r\n        ...(result.age && { age: result.age }),\r\n        relevanceScore: this.calculateRelevanceScore(result, options.query, index)\r\n      }));\r\n\r\n      const searchTime = Date.now() - startTime;\r\n      \r\n      const response: WebSearchResponse = {\r\n        query: options.query,\r\n        totalResults: formattedResults.length,\r\n        results: formattedResults,\r\n        searchTime,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n\r\n      console.log(`­ƒöì WebSearchTool: Found ${response.totalResults} results in ${searchTime}ms`);\r\n      return response;\r\n\r\n    } catch (error: any) {\r\n      console.error('ÔØî WebSearchTool error:', error.message);\r\n      \r\n      // Return empty results on error, but don't throw\r\n      return {\r\n        query: options.query,\r\n        totalResults: 0,\r\n        results: [],\r\n        searchTime: Date.now() - startTime,\r\n        timestamp: new Date().toISOString()\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Quick search with minimal options\r\n   */\r\n  async quickSearch(query: string, count: number = 3): Promise<WebSearchResponse> {\r\n    return this.search({ query, count });\r\n  }\r\n\r\n  /**\r\n   * Search for news/recent information\r\n   */\r\n  async searchNews(query: string, count: number = 5): Promise<WebSearchResponse> {\r\n    return this.search({ \r\n      query: `${query} news`, \r\n      count, \r\n      includeRecent: true \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Search with specific country/region\r\n   */\r\n  async searchByRegion(query: string, country: string, count: number = 5): Promise<WebSearchResponse> {\r\n    return this.search({ query, country, count });\r\n  }\r\n\r\n  /**\r\n   * Test the web search functionality\r\n   */\r\n  async testSearch(): Promise<boolean> {\r\n    try {\r\n      console.log('­ƒöì Testing web search functionality...');\r\n      \r\n      const testResult = await this.quickSearch('OpenAI GPT-4', 1);\r\n      const isWorking = testResult.totalResults > 0 || testResult.results.length >= 0;\r\n      \r\n      if (isWorking) {\r\n        console.log('Ô£à Web search test passed');\r\n      } else {\r\n        console.log('ÔÜá´©Å Web search test returned no results');\r\n      }\r\n      \r\n      return isWorking;\r\n    } catch (error) {\r\n      console.error('ÔØî Web search test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Combine results from multiple searches and remove duplicates\r\n   */\r\n  private combineAndDeduplicateResults(mainResults: BraveSearchResult[], recentResults: BraveSearchResult[]): BraveSearchResult[] {\r\n    const combined = [...mainResults];\r\n    const existingUrls = new Set(mainResults.map(r => r.url));\r\n\r\n    // Add recent results if they're not duplicates\r\n    for (const recentResult of recentResults) {\r\n      if (!existingUrls.has(recentResult.url)) {\r\n        combined.push(recentResult);\r\n        existingUrls.add(recentResult.url);\r\n      }\r\n    }\r\n\r\n    return combined;\r\n  }\r\n\r\n  /**\r\n   * Calculate a simple relevance score for results\r\n   */\r\n  private calculateRelevanceScore(result: BraveSearchResult, query: string, position: number): number {\r\n    let score = 100 - (position * 10); // Base score decreases with position\r\n    \r\n    const queryTerms = query.toLowerCase().split(' ');\r\n    const titleLower = result.title.toLowerCase();\r\n    const descLower = result.description.toLowerCase();\r\n    \r\n    // Boost score for query terms in title\r\n    for (const term of queryTerms) {\r\n      if (titleLower.includes(term)) {\r\n        score += 20;\r\n      }\r\n      if (descLower.includes(term)) {\r\n        score += 10;\r\n      }\r\n    }\r\n    \r\n    // Boost for recent results\r\n    if (result.age && (result.age.includes('hour') || result.age.includes('minute'))) {\r\n      score += 15;\r\n    }\r\n    \r\n    return Math.max(0, Math.min(100, score));\r\n  }\r\n\r\n  /**\r\n   * Get search tool configuration\r\n   */\r\n  getConfig() {\r\n    return {\r\n      provider: 'Brave Search',\r\n      clientConfig: this.braveClient.getConfig()\r\n    };\r\n  }\r\n}\r\n","usedDeprecatedRules":[]}]
